{"/home/travis/build/npmtest/node-npmtest-baobab/test.js":"/* istanbul instrument in package npmtest_baobab */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-baobab/lib.npmtest_baobab.js":"/* istanbul instrument in package npmtest_baobab */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_baobab = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_baobab = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-baobab/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-baobab && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_baobab */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_baobab\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_baobab.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_baobab.rollup.js'] =\n            local.assetsDict['/assets.npmtest_baobab.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_baobab.__dirname + '/lib.npmtest_baobab.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-baobab/node_modules/baobab/dist/baobab.js":"/**\n * Baobab Data Structure\n * ======================\n *\n * A handy data tree with cursors.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _emmett = require('emmett');\n\nvar _emmett2 = _interopRequireDefault(_emmett);\n\nvar _cursor = require('./cursor');\n\nvar _cursor2 = _interopRequireDefault(_cursor);\n\nvar _monkey = require('./monkey');\n\nvar _watcher = require('./watcher');\n\nvar _watcher2 = _interopRequireDefault(_watcher);\n\nvar _type = require('./type');\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _update2 = require('./update');\n\nvar _update3 = _interopRequireDefault(_update2);\n\nvar _helpers = require('./helpers');\n\nvar helpers = _interopRequireWildcard(_helpers);\n\nvar arrayFrom = helpers.arrayFrom;\nvar coercePath = helpers.coercePath;\nvar deepFreeze = helpers.deepFreeze;\nvar getIn = helpers.getIn;\nvar makeError = helpers.makeError;\nvar deepClone = helpers.deepClone;\nvar deepMerge = helpers.deepMerge;\nvar shallowClone = helpers.shallowClone;\nvar shallowMerge = helpers.shallowMerge;\nvar uniqid = helpers.uniqid;\n\n/**\n * Baobab defaults\n */\nvar DEFAULTS = {\n\n  // Should the tree handle its transactions on its own?\n  autoCommit: true,\n\n  // Should the transactions be handled asynchronously?\n  asynchronous: true,\n\n  // Should the tree's data be immutable?\n  immutable: true,\n\n  // Should the monkeys be lazy?\n  lazyMonkeys: true,\n\n  // Should the tree be persistent?\n  persistent: true,\n\n  // Should the tree's update be pure?\n  pure: true,\n\n  // Validation specifications\n  validate: null,\n\n  // Validation behavior 'rollback' or 'notify'\n  validationBehavior: 'rollback'\n};\n\n/**\n * Function returning a string hash from a non-dynamic path expressed as an\n * array.\n *\n * @param  {array}  path - The path to hash.\n * @return {string} string - The resultant hash.\n */\nfunction hashPath(path) {\n  return 'λ' + path.map(function (step) {\n    if (_type2['default']['function'](step) || _type2['default'].object(step)) return '#' + uniqid() + '#';\n\n    return step;\n  }).join('λ');\n}\n\n/**\n * Baobab class\n *\n * @constructor\n * @param {object|array} [initialData={}]    - Initial data passed to the tree.\n * @param {object}       [opts]              - Optional options.\n * @param {boolean}      [opts.autoCommit]   - Should the tree auto-commit?\n * @param {boolean}      [opts.asynchronous] - Should the tree's transactions\n *                                             handled asynchronously?\n * @param {boolean}      [opts.immutable]    - Should the tree be immutable?\n * @param {boolean}      [opts.persistent]   - Should the tree be persistent?\n * @param {boolean}      [opts.pure]         - Should the tree be pure?\n * @param {function}     [opts.validate]     - Validation function.\n * @param {string}       [opts.validationBehaviour] - \"rollback\" or \"notify\".\n */\n\nvar Baobab = (function (_Emitter) {\n  _inherits(Baobab, _Emitter);\n\n  function Baobab(initialData, opts) {\n    var _this = this;\n\n    _classCallCheck(this, Baobab);\n\n    _get(Object.getPrototypeOf(Baobab.prototype), 'constructor', this).call(this);\n\n    // Setting initialData to an empty object if no data is provided by use\n    if (arguments.length < 1) initialData = {};\n\n    // Checking whether given initial data is valid\n    if (!_type2['default'].object(initialData) && !_type2['default'].array(initialData)) throw makeError('Baobab: invalid data.', { data: initialData });\n\n    // Merging given options with defaults\n    this.options = shallowMerge({}, DEFAULTS, opts);\n\n    // Disabling immutability & persistence if persistence if disabled\n    if (!this.options.persistent) {\n      this.options.immutable = false;\n      this.options.pure = false;\n    }\n\n    // Privates\n    this._identity = '[object Baobab]';\n    this._cursors = {};\n    this._future = null;\n    this._transaction = [];\n    this._affectedPathsIndex = {};\n    this._monkeys = {};\n    this._previousData = null;\n    this._data = initialData;\n\n    // Properties\n    this.root = new _cursor2['default'](this, [], 'λ');\n    delete this.root.release;\n\n    // Does the user want an immutable tree?\n    if (this.options.immutable) deepFreeze(this._data);\n\n    // Bootstrapping root cursor's getters and setters\n    var bootstrap = function bootstrap(name) {\n      _this[name] = function () {\n        var r = this.root[name].apply(this.root, arguments);\n        return r instanceof _cursor2['default'] ? this : r;\n      };\n    };\n\n    ['apply', 'clone', 'concat', 'deepClone', 'deepMerge', 'exists', 'get', 'push', 'merge', 'pop', 'project', 'serialize', 'set', 'shift', 'splice', 'unset', 'unshift'].forEach(bootstrap);\n\n    // Registering the initial monkeys\n    this._refreshMonkeys();\n\n    // Initial validation\n    var validationError = this.validate();\n\n    if (validationError) throw Error('Baobab: invalid data.', { error: validationError });\n  }\n\n  /**\n   * Monkey helper.\n   */\n\n  /**\n   * Internal method used to refresh the tree's monkey register on every\n   * update.\n   * Note 1) For the time being, placing monkeys beneath array nodes is not\n   * allowed for performance reasons.\n   *\n   * @param  {mixed}   node      - The starting node.\n   * @param  {array}   path      - The starting node's path.\n   * @param  {string}  operation - The operation that lead to a refreshment.\n   * @return {Baobab}            - The tree instance for chaining purposes.\n   */\n\n  _createClass(Baobab, [{\n    key: '_refreshMonkeys',\n    value: function _refreshMonkeys(node, path, operation) {\n      var _this2 = this;\n\n      var clean = function clean(data) {\n        var p = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n        if (data instanceof _monkey.Monkey) {\n          data.release();\n          (0, _update3['default'])(_this2._monkeys, p, { type: 'unset' }, {\n            immutable: false,\n            persistent: false,\n            pure: false\n          });\n\n          return;\n        }\n\n        if (_type2['default'].object(data)) {\n          for (var k in data) {\n            clean(data[k], p.concat(k));\n          }\n        }\n      };\n\n      var walk = function walk(data) {\n        var p = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n        // Should we sit a monkey in the tree?\n        if (data instanceof _monkey.MonkeyDefinition || data instanceof _monkey.Monkey) {\n          var monkeyInstance = new _monkey.Monkey(_this2, p, data instanceof _monkey.Monkey ? data.definition : data);\n\n          (0, _update3['default'])(_this2._monkeys, p, { type: 'set', value: monkeyInstance }, {\n            immutable: false,\n            persistent: false,\n            pure: false\n          });\n\n          return;\n        }\n\n        // Object iteration\n        if (_type2['default'].object(data)) {\n          for (var k in data) {\n            walk(data[k], p.concat(k));\n          }\n        }\n      };\n\n      // Walking the whole tree\n      if (!arguments.length) {\n        walk(this._data);\n      } else {\n        var monkeysNode = getIn(this._monkeys, path).data;\n\n        // Is this required that we clean some already existing monkeys?\n        if (monkeysNode) clean(monkeysNode, path);\n\n        // Let's walk the tree only from the updated point\n        if (operation !== 'unset') {\n          walk(node, path);\n        }\n      }\n\n      return this;\n    }\n\n    /**\n     * Method used to validate the tree's data.\n     *\n     * @return {boolean} - Is the tree valid?\n     */\n  }, {\n    key: 'validate',\n    value: function validate(affectedPaths) {\n      var _options = this.options;\n      var validate = _options.validate;\n      var behavior = _options.validationBehavior;\n\n      if (typeof validate !== 'function') return null;\n\n      var error = validate.call(this, this._previousData, this._data, affectedPaths || [[]]);\n\n      if (error instanceof Error) {\n\n        if (behavior === 'rollback') {\n          this._data = this._previousData;\n          this._affectedPathsIndex = {};\n          this._transaction = [];\n          this._previousData = this._data;\n        }\n\n        this.emit('invalid', { error: error });\n\n        return error;\n      }\n\n      return null;\n    }\n\n    /**\n     * Method used to select data within the tree by creating a cursor. Cursors\n     * are kept as singletons by the tree for performance and hygiene reasons.\n     *\n     * Arity (1):\n     * @param {path}    path - Path to select in the tree.\n     *\n     * Arity (*):\n     * @param {...step} path - Path to select in the tree.\n     *\n     * @return {Cursor}      - The resultant cursor.\n     */\n  }, {\n    key: 'select',\n    value: function select(path) {\n\n      // If no path is given, we simply return the root\n      path = path || [];\n\n      // Variadic\n      if (arguments.length > 1) path = arrayFrom(arguments);\n\n      // Checking that given path is valid\n      if (!_type2['default'].path(path)) throw makeError('Baobab.select: invalid path.', { path: path });\n\n      // Casting to array\n      path = [].concat(path);\n\n      // Computing hash (done here because it would be too late to do it in the\n      // cursor's constructor since we need to hit the cursors' index first).\n      var hash = hashPath(path);\n\n      // Creating a new cursor or returning the already existing one for the\n      // requested path.\n      var cursor = this._cursors[hash];\n\n      if (!cursor) {\n        cursor = new _cursor2['default'](this, path, hash);\n        this._cursors[hash] = cursor;\n      }\n\n      // Emitting an event to notify that a part of the tree was selected\n      this.emit('select', { path: path, cursor: cursor });\n      return cursor;\n    }\n\n    /**\n     * Method used to update the tree. Updates are simply expressed by a path,\n     * dynamic or not, and an operation.\n     *\n     * This is where path solving should happen and not in the cursor.\n     *\n     * @param  {path}   path      - The path where we'll apply the operation.\n     * @param  {object} operation - The operation to apply.\n     * @return {mixed} - Return the result of the update.\n     */\n  }, {\n    key: 'update',\n    value: function update(path, operation) {\n      var _this3 = this;\n\n      // Coercing path\n      path = coercePath(path);\n\n      if (!_type2['default'].operationType(operation.type)) throw makeError('Baobab.update: unknown operation type \"' + operation.type + '\".', { operation: operation });\n\n      // Solving the given path\n\n      var _getIn = getIn(this._data, path);\n\n      var solvedPath = _getIn.solvedPath;\n      var exists = _getIn.exists;\n\n      // If we couldn't solve the path, we throw\n      if (!solvedPath) throw makeError('Baobab.update: could not solve the given path.', {\n        path: solvedPath\n      });\n\n      // Read-only path?\n      var monkeyPath = _type2['default'].monkeyPath(this._monkeys, solvedPath);\n      if (monkeyPath && solvedPath.length > monkeyPath.length) throw makeError('Baobab.update: attempting to update a read-only path.', {\n        path: solvedPath\n      });\n\n      // We don't unset irrelevant paths\n      if (operation.type === 'unset' && !exists) return;\n\n      // If we merge data, we need to acknowledge monkeys\n      var realOperation = operation;\n      if (/merge/i.test(operation.type)) {\n        var monkeysNode = getIn(this._monkeys, solvedPath).data;\n\n        if (_type2['default'].object(monkeysNode)) {\n\n          // Cloning the operation not to create weird behavior for the user\n          realOperation = shallowClone(realOperation);\n\n          // Fetching the existing node in the current data\n          var currentNode = getIn(this._data, solvedPath).data;\n\n          if (/deep/i.test(realOperation.type)) realOperation.value = deepMerge({}, deepMerge({}, currentNode, deepClone(monkeysNode)), realOperation.value);else realOperation.value = shallowMerge({}, deepMerge({}, currentNode, deepClone(monkeysNode)), realOperation.value);\n        }\n      }\n\n      // Stashing previous data if this is the frame's first update\n      if (!this._transaction.length) this._previousData = this._data;\n\n      // Applying the operation\n      var result = (0, _update3['default'])(this._data, solvedPath, realOperation, this.options);\n\n      var data = result.data;\n      var node = result.node;\n\n      // If because of purity, the update was moot, we stop here\n      if (!('data' in result)) return node;\n\n      // If the operation is push, the affected path is slightly different\n      var affectedPath = solvedPath.concat(operation.type === 'push' ? node.length - 1 : []);\n\n      var hash = hashPath(affectedPath);\n\n      // Updating data and transaction\n      this._data = data;\n      this._affectedPathsIndex[hash] = true;\n      this._transaction.push(shallowMerge({}, operation, { path: affectedPath }));\n\n      // Updating the monkeys\n      this._refreshMonkeys(node, solvedPath, operation.type);\n\n      // Emitting a `write` event\n      this.emit('write', { path: affectedPath });\n\n      // Should we let the user commit?\n      if (!this.options.autoCommit) return node;\n\n      // Should we update asynchronously?\n      if (!this.options.asynchronous) {\n        this.commit();\n        return node;\n      }\n\n      // Updating asynchronously\n      if (!this._future) this._future = setTimeout(function () {\n        return _this3.commit();\n      }, 0);\n\n      // Finally returning the affected node\n      return node;\n    }\n\n    /**\n     * Method committing the updates of the tree and firing the tree's events.\n     *\n     * @return {Baobab} - The tree instance for chaining purposes.\n     */\n  }, {\n    key: 'commit',\n    value: function commit() {\n\n      // Do not fire update if the transaction is empty\n      if (!this._transaction.length) return this;\n\n      // Clearing timeout if one was defined\n      if (this._future) this._future = clearTimeout(this._future);\n\n      var affectedPaths = Object.keys(this._affectedPathsIndex).map(function (h) {\n        return h !== 'λ' ? h.split('λ').slice(1) : [];\n      });\n\n      // Is the tree still valid?\n      var validationError = this.validate(affectedPaths);\n\n      if (validationError) return this;\n\n      // Caching to keep original references before we change them\n      var transaction = this._transaction,\n          previousData = this._previousData;\n\n      this._affectedPathsIndex = {};\n      this._transaction = [];\n      this._previousData = this._data;\n\n      // Emitting update event\n      this.emit('update', {\n        paths: affectedPaths,\n        currentData: this._data,\n        transaction: transaction,\n        previousData: previousData\n      });\n\n      return this;\n    }\n\n    /**\n     * Method returning a monkey at the given path or else `null`.\n     *\n     * @param  {path}        path - Path of the monkey to retrieve.\n     * @return {Monkey|null}      - The Monkey instance of `null`.\n     */\n  }, {\n    key: 'getMonkey',\n    value: function getMonkey(path) {\n      path = coercePath(path);\n\n      var monkey = getIn(this._monkeys, [].concat(path)).data;\n\n      if (monkey instanceof _monkey.Monkey) return monkey;\n\n      return null;\n    }\n\n    /**\n     * Method used to watch a collection of paths within the tree. Very useful\n     * to bind UI components and such to the tree.\n     *\n     * @param  {object} mapping - Mapping of paths to listen.\n     * @return {Cursor}         - The created watcher.\n     */\n  }, {\n    key: 'watch',\n    value: function watch(mapping) {\n      return new _watcher2['default'](this, mapping);\n    }\n\n    /**\n     * Method releasing the tree and its attached data from memory.\n     */\n  }, {\n    key: 'release',\n    value: function release() {\n      var k = undefined;\n\n      this.emit('release');\n\n      delete this.root;\n\n      delete this._data;\n      delete this._previousData;\n      delete this._transaction;\n      delete this._affectedPathsIndex;\n      delete this._monkeys;\n\n      // Releasing cursors\n      for (k in this._cursors) this._cursors[k].release();\n      delete this._cursors;\n\n      // Killing event emitter\n      this.kill();\n    }\n\n    /**\n     * Overriding the `toJSON` method for convenient use with JSON.stringify.\n     *\n     * @return {mixed} - Data at cursor.\n     */\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return this.serialize();\n    }\n\n    /**\n     * Overriding the `toString` method for debugging purposes.\n     *\n     * @return {string} - The baobab's identity.\n     */\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this._identity;\n    }\n  }]);\n\n  return Baobab;\n})(_emmett2['default']);\n\nexports['default'] = Baobab;\nBaobab.monkey = function () {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  if (!args.length) throw new Error('Baobab.monkey: missing definition.');\n\n  if (args.length === 1 && typeof args[0] !== 'function') return new _monkey.MonkeyDefinition(args[0]);\n\n  return new _monkey.MonkeyDefinition(args);\n};\nBaobab.dynamicNode = Baobab.monkey;\n\n/**\n * Exposing some internals for convenience\n */\nBaobab.Cursor = _cursor2['default'];\nBaobab.MonkeyDefinition = _monkey.MonkeyDefinition;\nBaobab.Monkey = _monkey.Monkey;\nBaobab.type = _type2['default'];\nBaobab.helpers = helpers;\n\n/**\n * Version\n */\nBaobab.VERSION = '2.4.3';\nmodule.exports = exports['default'];","/home/travis/build/npmtest/node-npmtest-baobab/node_modules/baobab/dist/cursor.js":"/**\n * Baobab Cursors\n * ===============\n *\n * Cursors created by selecting some data within a Baobab tree.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _emmett = require('emmett');\n\nvar _emmett2 = _interopRequireDefault(_emmett);\n\nvar _monkey = require('./monkey');\n\nvar _type = require('./type');\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _helpers = require('./helpers');\n\n/**\n * Traversal helper function for dynamic cursors. Will throw a legible error\n * if traversal is not possible.\n *\n * @param {string} method     - The method name, to create a correct error msg.\n * @param {array}  solvedPath - The cursor's solved path.\n */\nfunction checkPossibilityOfDynamicTraversal(method, solvedPath) {\n  if (!solvedPath) throw (0, _helpers.makeError)('Baobab.Cursor.' + method + ': ' + ('cannot use ' + method + ' on an unresolved dynamic path.'), { path: solvedPath });\n}\n\n/**\n * Cursor class\n *\n * @constructor\n * @param {Baobab} tree   - The cursor's root.\n * @param {array}  path   - The cursor's path in the tree.\n * @param {string} hash   - The path's hash computed ahead by the tree.\n */\n\nvar Cursor = (function (_Emitter) {\n  _inherits(Cursor, _Emitter);\n\n  function Cursor(tree, path, hash) {\n    var _this = this;\n\n    _classCallCheck(this, Cursor);\n\n    _get(Object.getPrototypeOf(Cursor.prototype), 'constructor', this).call(this);\n\n    // If no path were to be provided, we fallback to an empty path (root)\n    path = path || [];\n\n    // Privates\n    this._identity = '[object Cursor]';\n    this._archive = null;\n\n    // Properties\n    this.tree = tree;\n    this.path = path;\n    this.hash = hash;\n\n    // State\n    this.state = {\n      killed: false,\n      recording: false,\n      undoing: false\n    };\n\n    // Checking whether the given path is dynamic or not\n    this._dynamicPath = _type2['default'].dynamicPath(this.path);\n\n    // Checking whether the given path will meet a monkey\n    this._monkeyPath = _type2['default'].monkeyPath(this.tree._monkeys, this.path);\n\n    if (!this._dynamicPath) this.solvedPath = this.path;else this.solvedPath = (0, _helpers.getIn)(this.tree._data, this.path).solvedPath;\n\n    /**\n     * Listener bound to the tree's writes so that cursors with dynamic paths\n     * may update their solved path correctly.\n     *\n     * @param {object} event - The event fired by the tree.\n     */\n    this._writeHandler = function (_ref) {\n      var data = _ref.data;\n\n      if (_this.state.killed || !(0, _helpers.solveUpdate)([data.path], _this._getComparedPaths())) return;\n\n      _this.solvedPath = (0, _helpers.getIn)(_this.tree._data, _this.path).solvedPath;\n    };\n\n    /**\n     * Function in charge of actually trigger the cursor's updates and\n     * deal with the archived records.\n     *\n     * @note: probably should wrap the current solvedPath in closure to avoid\n     * for tricky cases where it would fail.\n     *\n     * @param {mixed} previousData - the tree's previous data.\n     */\n    var fireUpdate = function fireUpdate(previousData) {\n      var self = _this;\n\n      var eventData = Object.defineProperties({}, {\n        previousData: {\n          get: function get() {\n            return (0, _helpers.getIn)(previousData, self.solvedPath).data;\n          },\n          configurable: true,\n          enumerable: true\n        },\n        currentData: {\n          get: function get() {\n            return self.get();\n          },\n          configurable: true,\n          enumerable: true\n        }\n      });\n\n      if (_this.state.recording && !_this.state.undoing) _this.archive.add(eventData.previousData);\n\n      _this.state.undoing = false;\n\n      return _this.emit('update', eventData);\n    };\n\n    /**\n     * Listener bound to the tree's updates and determining whether the\n     * cursor is affected and should react accordingly.\n     *\n     * Note that this listener is lazily bound to the tree to be sure\n     * one wouldn't leak listeners when only creating cursors for convenience\n     * and not to listen to updates specifically.\n     *\n     * @param {object} event - The event fired by the tree.\n     */\n    this._updateHandler = function (event) {\n      if (_this.state.killed) return;\n\n      var _event$data = event.data;\n      var paths = _event$data.paths;\n      var previousData = _event$data.previousData;\n      var update = fireUpdate.bind(_this, previousData);\n      var comparedPaths = _this._getComparedPaths();\n\n      if ((0, _helpers.solveUpdate)(paths, comparedPaths)) return update();\n    };\n\n    // Lazy binding\n    var bound = false;\n    this._lazyBind = function () {\n      if (bound) return;\n\n      bound = true;\n\n      if (_this._dynamicPath) _this.tree.on('write', _this._writeHandler);\n\n      return _this.tree.on('update', _this._updateHandler);\n    };\n\n    // If the path is dynamic, we actually need to listen to the tree\n    if (this._dynamicPath) {\n      this._lazyBind();\n    } else {\n\n      // Overriding the emitter `on` and `once` methods\n      this.on = (0, _helpers.before)(this._lazyBind, this.on.bind(this));\n      this.once = (0, _helpers.before)(this._lazyBind, this.once.bind(this));\n    }\n  }\n\n  /**\n   * Method used to allow iterating over cursors containing list-type data.\n   *\n   * e.g. for(let i of cursor) { ... }\n   *\n   * @returns {object} -  Each item sequentially.\n   */\n\n  /**\n   * Internal helpers\n   * -----------------\n   */\n\n  /**\n   * Method returning the paths of the tree watched over by the cursor and that\n   * should be taken into account when solving a potential update.\n   *\n   * @return {array} - Array of paths to compare with a given update.\n   */\n\n  _createClass(Cursor, [{\n    key: '_getComparedPaths',\n    value: function _getComparedPaths() {\n\n      // Checking whether we should keep track of some dependencies\n      var additionalPaths = this._monkeyPath ? (0, _helpers.getIn)(this.tree._monkeys, this._monkeyPath).data.relatedPaths() : [];\n\n      return [this.solvedPath].concat(additionalPaths);\n    }\n\n    /**\n     * Predicates\n     * -----------\n     */\n\n    /**\n     * Method returning whether the cursor is at root level.\n     *\n     * @return {boolean} - Is the cursor the root?\n     */\n  }, {\n    key: 'isRoot',\n    value: function isRoot() {\n      return !this.path.length;\n    }\n\n    /**\n     * Method returning whether the cursor is at leaf level.\n     *\n     * @return {boolean} - Is the cursor a leaf?\n     */\n  }, {\n    key: 'isLeaf',\n    value: function isLeaf() {\n      return _type2['default'].primitive(this._get().data);\n    }\n\n    /**\n     * Method returning whether the cursor is at branch level.\n     *\n     * @return {boolean} - Is the cursor a branch?\n     */\n  }, {\n    key: 'isBranch',\n    value: function isBranch() {\n      return !this.isRoot() && !this.isLeaf();\n    }\n\n    /**\n     * Traversal Methods\n     * ------------------\n     */\n\n    /**\n     * Method returning the root cursor.\n     *\n     * @return {Baobab} - The root cursor.\n     */\n  }, {\n    key: 'root',\n    value: function root() {\n      return this.tree.select();\n    }\n\n    /**\n     * Method selecting a subpath as a new cursor.\n     *\n     * Arity (1):\n     * @param  {path} path    - The path to select.\n     *\n     * Arity (*):\n     * @param  {...step} path - The path to select.\n     *\n     * @return {Cursor}       - The created cursor.\n     */\n  }, {\n    key: 'select',\n    value: function select(path) {\n      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\n      return this.tree.select(this.path.concat(path));\n    }\n\n    /**\n     * Method returning the parent node of the cursor or else `null` if the\n     * cursor is already at root level.\n     *\n     * @return {Baobab} - The parent cursor.\n     */\n  }, {\n    key: 'up',\n    value: function up() {\n      if (!this.isRoot()) return this.tree.select(this.path.slice(0, -1));\n\n      return null;\n    }\n\n    /**\n     * Method returning the child node of the cursor.\n     *\n     * @return {Baobab} - The child cursor.\n     */\n  }, {\n    key: 'down',\n    value: function down() {\n      checkPossibilityOfDynamicTraversal('down', this.solvedPath);\n\n      if (!(this._get().data instanceof Array)) throw Error('Baobab.Cursor.down: cannot go down on a non-list type.');\n\n      return this.tree.select(this.solvedPath.concat(0));\n    }\n\n    /**\n     * Method returning the left sibling node of the cursor if this one is\n     * pointing at a list. Returns `null` if this cursor is already leftmost.\n     *\n     * @return {Baobab} - The left sibling cursor.\n     */\n  }, {\n    key: 'left',\n    value: function left() {\n      checkPossibilityOfDynamicTraversal('left', this.solvedPath);\n\n      var last = +this.solvedPath[this.solvedPath.length - 1];\n\n      if (isNaN(last)) throw Error('Baobab.Cursor.left: cannot go left on a non-list type.');\n\n      return last ? this.tree.select(this.solvedPath.slice(0, -1).concat(last - 1)) : null;\n    }\n\n    /**\n     * Method returning the right sibling node of the cursor if this one is\n     * pointing at a list. Returns `null` if this cursor is already rightmost.\n     *\n     * @return {Baobab} - The right sibling cursor.\n     */\n  }, {\n    key: 'right',\n    value: function right() {\n      checkPossibilityOfDynamicTraversal('right', this.solvedPath);\n\n      var last = +this.solvedPath[this.solvedPath.length - 1];\n\n      if (isNaN(last)) throw Error('Baobab.Cursor.right: cannot go right on a non-list type.');\n\n      if (last + 1 === this.up()._get().data.length) return null;\n\n      return this.tree.select(this.solvedPath.slice(0, -1).concat(last + 1));\n    }\n\n    /**\n     * Method returning the leftmost sibling node of the cursor if this one is\n     * pointing at a list.\n     *\n     * @return {Baobab} - The leftmost sibling cursor.\n     */\n  }, {\n    key: 'leftmost',\n    value: function leftmost() {\n      checkPossibilityOfDynamicTraversal('leftmost', this.solvedPath);\n\n      var last = +this.solvedPath[this.solvedPath.length - 1];\n\n      if (isNaN(last)) throw Error('Baobab.Cursor.leftmost: cannot go left on a non-list type.');\n\n      return this.tree.select(this.solvedPath.slice(0, -1).concat(0));\n    }\n\n    /**\n     * Method returning the rightmost sibling node of the cursor if this one is\n     * pointing at a list.\n     *\n     * @return {Baobab} - The rightmost sibling cursor.\n     */\n  }, {\n    key: 'rightmost',\n    value: function rightmost() {\n      checkPossibilityOfDynamicTraversal('rightmost', this.solvedPath);\n\n      var last = +this.solvedPath[this.solvedPath.length - 1];\n\n      if (isNaN(last)) throw Error('Baobab.Cursor.rightmost: cannot go right on a non-list type.');\n\n      var list = this.up()._get().data;\n\n      return this.tree.select(this.solvedPath.slice(0, -1).concat(list.length - 1));\n    }\n\n    /**\n     * Method mapping the children nodes of the cursor.\n     *\n     * @param  {function} fn      - The function to map.\n     * @param  {object}   [scope] - An optional scope.\n     * @return {array}            - The resultant array.\n     */\n  }, {\n    key: 'map',\n    value: function map(fn, scope) {\n      checkPossibilityOfDynamicTraversal('map', this.solvedPath);\n\n      var array = this._get().data,\n          l = arguments.length;\n\n      if (!_type2['default'].array(array)) throw Error('baobab.Cursor.map: cannot map a non-list type.');\n\n      return array.map(function (item, i) {\n        return fn.call(l > 1 ? scope : this, this.select(i), i, array);\n      }, this);\n    }\n\n    /**\n     * Getter Methods\n     * ---------------\n     */\n\n    /**\n     * Internal get method. Basically contains the main body of the `get` method\n     * without the event emitting. This is sometimes needed not to fire useless\n     * events.\n     *\n     * @param  {path}   [path=[]]       - Path to get in the tree.\n     * @return {object} info            - The resultant information.\n     * @return {mixed}  info.data       - Data at path.\n     * @return {array}  info.solvedPath - The path solved when getting.\n     */\n  }, {\n    key: '_get',\n    value: function _get() {\n      var path = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\n      if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.getters: invalid path.', { path: path });\n\n      if (!this.solvedPath) return { data: undefined, solvedPath: null, exists: false };\n\n      return (0, _helpers.getIn)(this.tree._data, this.solvedPath.concat(path));\n    }\n\n    /**\n     * Method used to check whether a certain path exists in the tree starting\n     * from the current cursor.\n     *\n     * Arity (1):\n     * @param  {path}   path           - Path to check in the tree.\n     *\n     * Arity (2):\n     * @param {..step}  path           - Path to check in the tree.\n     *\n     * @return {boolean}               - Does the given path exists?\n     */\n  }, {\n    key: 'exists',\n    value: function exists(path) {\n      path = (0, _helpers.coercePath)(path);\n\n      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\n      return this._get(path).exists;\n    }\n\n    /**\n     * Method used to get data from the tree. Will fire a `get` event from the\n     * tree so that the user may sometimes react upon it to fetch data, for\n     * instance.\n     *\n     * Arity (1):\n     * @param  {path}   path           - Path to get in the tree.\n     *\n     * Arity (2):\n     * @param  {..step} path           - Path to get in the tree.\n     *\n     * @return {mixed}                 - Data at path.\n     */\n  }, {\n    key: 'get',\n    value: function get(path) {\n      path = (0, _helpers.coercePath)(path);\n\n      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\n      var _get2 = this._get(path);\n\n      var data = _get2.data;\n      var solvedPath = _get2.solvedPath;\n\n      // Emitting the event\n      this.tree.emit('get', { data: data, solvedPath: solvedPath, path: this.path.concat(path) });\n\n      return data;\n    }\n\n    /**\n     * Method used to shallow clone data from the tree.\n     *\n     * Arity (1):\n     * @param  {path}   path           - Path to get in the tree.\n     *\n     * Arity (2):\n     * @param  {..step} path           - Path to get in the tree.\n     *\n     * @return {mixed}                 - Cloned data at path.\n     */\n  }, {\n    key: 'clone',\n    value: function clone() {\n      var data = this.get.apply(this, arguments);\n\n      return (0, _helpers.shallowClone)(data);\n    }\n\n    /**\n     * Method used to deep clone data from the tree.\n     *\n     * Arity (1):\n     * @param  {path}   path           - Path to get in the tree.\n     *\n     * Arity (2):\n     * @param  {..step} path           - Path to get in the tree.\n     *\n     * @return {mixed}                 - Cloned data at path.\n     */\n  }, {\n    key: 'deepClone',\n    value: function deepClone() {\n      var data = this.get.apply(this, arguments);\n\n      return (0, _helpers.deepClone)(data);\n    }\n\n    /**\n     * Method used to return raw data from the tree, by carefully avoiding\n     * computed one.\n     *\n     * @todo: should be more performant as the cloning should happen as well as\n     * when dropping computed data.\n     *\n     * Arity (1):\n     * @param  {path}   path           - Path to serialize in the tree.\n     *\n     * Arity (2):\n     * @param  {..step} path           - Path to serialize in the tree.\n     *\n     * @return {mixed}                 - The retrieved raw data.\n     */\n  }, {\n    key: 'serialize',\n    value: function serialize(path) {\n      path = (0, _helpers.coercePath)(path);\n\n      if (arguments.length > 1) path = (0, _helpers.arrayFrom)(arguments);\n\n      if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.getters: invalid path.', { path: path });\n\n      if (!this.solvedPath) return undefined;\n\n      var fullPath = this.solvedPath.concat(path);\n\n      var data = (0, _helpers.deepClone)((0, _helpers.getIn)(this.tree._data, fullPath).data),\n          monkeys = (0, _helpers.getIn)(this.tree._monkeys, fullPath).data;\n\n      var dropComputedData = function dropComputedData(d, m) {\n        if (!_type2['default'].object(m) || !_type2['default'].object(d)) return;\n\n        for (var k in m) {\n          if (m[k] instanceof _monkey.Monkey) delete d[k];else dropComputedData(d[k], m[k]);\n        }\n      };\n\n      dropComputedData(data, monkeys);\n      return data;\n    }\n\n    /**\n     * Method used to project some of the data at cursor onto a map or a list.\n     *\n     * @param  {object|array} projection - The projection's formal definition.\n     * @return {object|array}            - The resultant map/list.\n     */\n  }, {\n    key: 'project',\n    value: function project(projection) {\n      if (_type2['default'].object(projection)) {\n        var data = {};\n\n        for (var k in projection) {\n          data[k] = this.get(projection[k]);\n        }return data;\n      } else if (_type2['default'].array(projection)) {\n        var data = [];\n\n        for (var i = 0, l = projection.length; i < l; i++) {\n          data.push(this.get(projection[i]));\n        }return data;\n      }\n\n      throw (0, _helpers.makeError)('Baobab.Cursor.project: wrong projection.', { projection: projection });\n    }\n\n    /**\n     * History Methods\n     * ----------------\n     */\n\n    /**\n     * Methods starting to record the cursor's successive states.\n     *\n     * @param  {integer} [maxRecords] - Maximum records to keep in memory. Note\n     *                                  that if no number is provided, the cursor\n     *                                  will keep everything.\n     * @return {Cursor}               - The cursor instance for chaining purposes.\n     */\n  }, {\n    key: 'startRecording',\n    value: function startRecording(maxRecords) {\n      maxRecords = maxRecords || Infinity;\n\n      if (maxRecords < 1) throw (0, _helpers.makeError)('Baobab.Cursor.startRecording: invalid max records.', {\n        value: maxRecords\n      });\n\n      this.state.recording = true;\n\n      if (this.archive) return this;\n\n      // Lazy binding\n      this._lazyBind();\n\n      this.archive = new _helpers.Archive(maxRecords);\n      return this;\n    }\n\n    /**\n     * Methods stopping to record the cursor's successive states.\n     *\n     * @return {Cursor} - The cursor instance for chaining purposes.\n     */\n  }, {\n    key: 'stopRecording',\n    value: function stopRecording() {\n      this.state.recording = false;\n      return this;\n    }\n\n    /**\n     * Methods undoing n steps of the cursor's recorded states.\n     *\n     * @param  {integer} [steps=1] - The number of steps to rollback.\n     * @return {Cursor}            - The cursor instance for chaining purposes.\n     */\n  }, {\n    key: 'undo',\n    value: function undo() {\n      var steps = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];\n\n      if (!this.state.recording) throw new Error('Baobab.Cursor.undo: cursor is not recording.');\n\n      var record = this.archive.back(steps);\n\n      if (!record) throw Error('Baobab.Cursor.undo: cannot find a relevant record.');\n\n      this.state.undoing = true;\n      this.set(record);\n\n      return this;\n    }\n\n    /**\n     * Methods returning whether the cursor has a recorded history.\n     *\n     * @return {boolean} - `true` if the cursor has a recorded history?\n     */\n  }, {\n    key: 'hasHistory',\n    value: function hasHistory() {\n      return !!(this.archive && this.archive.get().length);\n    }\n\n    /**\n     * Methods returning the cursor's history.\n     *\n     * @return {array} - The cursor's history.\n     */\n  }, {\n    key: 'getHistory',\n    value: function getHistory() {\n      return this.archive ? this.archive.get() : [];\n    }\n\n    /**\n     * Methods clearing the cursor's history.\n     *\n     * @return {Cursor} - The cursor instance for chaining purposes.\n     */\n  }, {\n    key: 'clearHistory',\n    value: function clearHistory() {\n      if (this.archive) this.archive.clear();\n      return this;\n    }\n\n    /**\n     * Releasing\n     * ----------\n     */\n\n    /**\n     * Methods releasing the cursor from memory.\n     */\n  }, {\n    key: 'release',\n    value: function release() {\n\n      // Removing listeners on parent\n      if (this._dynamicPath) this.tree.off('write', this._writeHandler);\n\n      this.tree.off('update', this._updateHandler);\n\n      // Unsubscribe from the parent\n      if (this.hash) delete this.tree._cursors[this.hash];\n\n      // Dereferencing\n      delete this.tree;\n      delete this.path;\n      delete this.solvedPath;\n      delete this.archive;\n\n      // Killing emitter\n      this.kill();\n      this.state.killed = true;\n    }\n\n    /**\n     * Output\n     * -------\n     */\n\n    /**\n     * Overriding the `toJSON` method for convenient use with JSON.stringify.\n     *\n     * @return {mixed} - Data at cursor.\n     */\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      return this.serialize();\n    }\n\n    /**\n     * Overriding the `toString` method for debugging purposes.\n     *\n     * @return {string} - The cursor's identity.\n     */\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this._identity;\n    }\n  }]);\n\n  return Cursor;\n})(_emmett2['default']);\n\nexports['default'] = Cursor;\nif (typeof Symbol === 'function' && typeof Symbol.iterator !== 'undefined') {\n  Cursor.prototype[Symbol.iterator] = function () {\n    var array = this._get().data;\n\n    if (!_type2['default'].array(array)) throw Error('baobab.Cursor.@@iterate: cannot iterate a non-list type.');\n\n    var i = 0;\n\n    var cursor = this,\n        length = array.length;\n\n    return {\n      next: function next() {\n        if (i < length) {\n          return {\n            value: cursor.select(i++)\n          };\n        }\n\n        return {\n          done: true\n        };\n      }\n    };\n  };\n}\n\n/**\n * Setter Methods\n * ---------------\n *\n * Those methods are dynamically assigned to the class for DRY reasons.\n */\n\n// Not using a Set so that ES5 consumers don't pay a bundle size price\nvar INTRANSITIVE_SETTERS = {\n  unset: true,\n  pop: true,\n  shift: true\n};\n\n/**\n * Function creating a setter method for the Cursor class.\n *\n * @param {string}   name          - the method's name.\n * @param {function} [typeChecker] - a function checking that the given value is\n *                                   valid for the given operation.\n */\nfunction makeSetter(name, typeChecker) {\n\n  /**\n   * Binding a setter method to the Cursor class and having the following\n   * definition.\n   *\n   * Note: this is not really possible to make those setters variadic because\n   * it would create an impossible polymorphism with path.\n   *\n   * @todo: perform value validation elsewhere so that tree.update can\n   * beneficiate from it.\n   *\n   * Arity (1):\n   * @param  {mixed} value - New value to set at cursor's path.\n   *\n   * Arity (2):\n   * @param  {path}  path  - Subpath to update starting from cursor's.\n   * @param  {mixed} value - New value to set.\n   *\n   * @return {mixed}       - Data at path.\n   */\n  Cursor.prototype[name] = function (path, value) {\n\n    // We should warn the user if he applies to many arguments to the function\n    if (arguments.length > 2) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': too many arguments.');\n\n    // Handling arities\n    if (arguments.length === 1 && !INTRANSITIVE_SETTERS[name]) {\n      value = path;\n      path = [];\n    }\n\n    // Coerce path\n    path = (0, _helpers.coercePath)(path);\n\n    // Checking the path's validity\n    if (!_type2['default'].path(path)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid path.', { path: path });\n\n    // Checking the value's validity\n    if (typeChecker && !typeChecker(value)) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': invalid value.', { path: path, value: value });\n\n    // Checking the solvability of the cursor's dynamic path\n    if (!this.solvedPath) throw (0, _helpers.makeError)('Baobab.Cursor.' + name + ': the dynamic path of the cursor cannot be solved.', { path: this.path });\n\n    var fullPath = this.solvedPath.concat(path);\n\n    // Filing the update to the tree\n    return this.tree.update(fullPath, {\n      type: name,\n      value: value\n    });\n  };\n}\n\n/**\n * Making the necessary setters.\n */\nmakeSetter('set');\nmakeSetter('unset');\nmakeSetter('apply', _type2['default']['function']);\nmakeSetter('push');\nmakeSetter('concat', _type2['default'].array);\nmakeSetter('unshift');\nmakeSetter('pop');\nmakeSetter('shift');\nmakeSetter('splice', _type2['default'].splicer);\nmakeSetter('merge', _type2['default'].object);\nmakeSetter('deepMerge', _type2['default'].object);\nmodule.exports = exports['default'];","/home/travis/build/npmtest/node-npmtest-baobab/node_modules/baobab/dist/monkey.js":"/**\n * Baobab Monkeys\n * ===============\n *\n * Exposing both handy monkey definitions and the underlying working class.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _type = require('./type');\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _update2 = require('./update');\n\nvar _update3 = _interopRequireDefault(_update2);\n\nvar _helpers = require('./helpers');\n\n/**\n * Monkey Definition class\n * Note: The only reason why this is a class is to be able to spot it within\n * otherwise ordinary data.\n *\n * @constructor\n * @param {array|object} definition - The formal definition of the monkey.\n */\n\nvar MonkeyDefinition = function MonkeyDefinition(definition) {\n  var _this = this;\n\n  _classCallCheck(this, MonkeyDefinition);\n\n  var monkeyType = _type2['default'].monkeyDefinition(definition);\n\n  if (!monkeyType) throw (0, _helpers.makeError)('Baobab.monkey: invalid definition.', { definition: definition });\n\n  this.type = monkeyType;\n\n  if (this.type === 'object') {\n    this.getter = definition.get;\n    this.projection = definition.cursors || {};\n    this.paths = Object.keys(this.projection).map(function (k) {\n      return _this.projection[k];\n    });\n    this.options = definition.options || {};\n  } else {\n    var offset = 1,\n        options = {};\n\n    if (_type2['default'].object(definition[definition.length - 1])) {\n      offset++;\n      options = definition[definition.length - 1];\n    }\n\n    this.getter = definition[definition.length - offset];\n    this.projection = definition.slice(0, -offset);\n    this.paths = this.projection;\n    this.options = options;\n  }\n\n  // Coercing paths for convenience\n  this.paths = this.paths.map(function (p) {\n    return [].concat(p);\n  });\n\n  // Does the definition contain dynamic paths\n  this.hasDynamicPaths = this.paths.some(_type2['default'].dynamicPath);\n}\n\n/**\n * Monkey core class\n *\n * @constructor\n * @param {Baobab}           tree       - The bound tree.\n * @param {MonkeyDefinition} definition - A definition instance.\n */\n;\n\nexports.MonkeyDefinition = MonkeyDefinition;\n\nvar Monkey = (function () {\n  function Monkey(tree, pathInTree, definition) {\n    var _this2 = this;\n\n    _classCallCheck(this, Monkey);\n\n    // Properties\n    this.tree = tree;\n    this.path = pathInTree;\n    this.definition = definition;\n\n    // Adapting the definition's paths & projection to this monkey's case\n    var projection = definition.projection,\n        relative = _helpers.solveRelativePath.bind(null, pathInTree.slice(0, -1));\n\n    if (definition.type === 'object') {\n      this.projection = Object.keys(projection).reduce(function (acc, k) {\n        acc[k] = relative(projection[k]);\n        return acc;\n      }, {});\n      this.depPaths = Object.keys(this.projection).map(function (k) {\n        return _this2.projection[k];\n      });\n    } else {\n      this.projection = projection.map(relative);\n      this.depPaths = this.projection;\n    }\n\n    // Internal state\n    this.state = {\n      killed: false\n    };\n\n    /**\n     * Listener on the tree's `write` event.\n     *\n     * When the tree writes, this listener will check whether the updated paths\n     * are of any use to the monkey and, if so, will update the tree's node\n     * where the monkey sits.\n     */\n    this.writeListener = function (_ref) {\n      var path = _ref.data.path;\n\n      if (_this2.state.killed) return;\n\n      // Is the monkey affected by the current write event?\n      var concerned = (0, _helpers.solveUpdate)([path], _this2.relatedPaths());\n\n      if (concerned) _this2.update();\n    };\n\n    /**\n     * Listener on the tree's `monkey` event.\n     *\n     * When another monkey updates, this listener will check whether the\n     * updated paths are of any use to the monkey and, if so, will update the\n     * tree's node where the monkey sits.\n     */\n    this.recursiveListener = function (_ref2) {\n      var _ref2$data = _ref2.data;\n      var monkey = _ref2$data.monkey;\n      var path = _ref2$data.path;\n\n      if (_this2.state.killed) return;\n\n      // Breaking if this is the same monkey\n      if (_this2 === monkey) return;\n\n      // Is the monkey affected by the current monkey event?\n      var concerned = (0, _helpers.solveUpdate)([path], _this2.relatedPaths(false));\n\n      if (concerned) _this2.update();\n    };\n\n    // Binding listeners\n    this.tree.on('write', this.writeListener);\n    this.tree.on('_monkey', this.recursiveListener);\n\n    // Updating relevant node\n    this.update();\n  }\n\n  /**\n   * Method returning solved paths related to the monkey.\n   *\n   * @param  {boolean} recursive - Should we compute recursive paths?\n   * @return {array}             - An array of related paths.\n   */\n\n  _createClass(Monkey, [{\n    key: 'relatedPaths',\n    value: function relatedPaths() {\n      var _this3 = this;\n\n      var recursive = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\n\n      var paths = undefined;\n\n      if (this.definition.hasDynamicPaths) paths = this.depPaths.map(function (p) {\n        return (0, _helpers.getIn)(_this3.tree._data, p).solvedPath;\n      });else paths = this.depPaths;\n\n      var isRecursive = recursive && this.depPaths.some(function (p) {\n        return !!_type2['default'].monkeyPath(_this3.tree._monkeys, p);\n      });\n\n      if (!isRecursive) return paths;\n\n      return paths.reduce(function (accumulatedPaths, path) {\n        var monkeyPath = _type2['default'].monkeyPath(_this3.tree._monkeys, path);\n\n        if (!monkeyPath) return accumulatedPaths.concat([path]);\n\n        // Solving recursive path\n        var relatedMonkey = (0, _helpers.getIn)(_this3.tree._monkeys, monkeyPath).data;\n\n        return accumulatedPaths.concat(relatedMonkey.relatedPaths());\n      }, []);\n    }\n\n    /**\n     * Method used to update the tree's internal data with a lazy getter holding\n     * the computed data.\n     *\n     * @return {Monkey} - Returns itself for chaining purposes.\n     */\n  }, {\n    key: 'update',\n    value: function update() {\n      var deps = this.tree.project(this.projection);\n\n      var lazyGetter = (function (tree, def, data) {\n        var cache = null,\n            alreadyComputed = false;\n\n        return function () {\n\n          if (!alreadyComputed) {\n            cache = def.getter.apply(tree, def.type === 'object' ? [data] : data);\n\n            if (tree.options.immutable && def.options.immutable !== false) (0, _helpers.deepFreeze)(cache);\n\n            alreadyComputed = true;\n          }\n\n          return cache;\n        };\n      })(this.tree, this.definition, deps);\n\n      lazyGetter.isLazyGetter = true;\n\n      // Should we write the lazy getter in the tree or solve it right now?\n      if (this.tree.options.lazyMonkeys) {\n        this.tree._data = (0, _update3['default'])(this.tree._data, this.path, {\n          type: 'monkey',\n          value: lazyGetter\n        }, this.tree.options).data;\n      } else {\n        var result = (0, _update3['default'])(this.tree._data, this.path, {\n          type: 'set',\n          value: lazyGetter(),\n          options: {\n            mutableLeaf: !this.definition.options.immutable\n          }\n        }, this.tree.options);\n\n        if ('data' in result) this.tree._data = result.data;\n      }\n\n      // Notifying the monkey's update so we can handle recursivity\n      this.tree.emit('_monkey', { monkey: this, path: this.path });\n\n      return this;\n    }\n\n    /**\n     * Method releasing the monkey from memory.\n     */\n  }, {\n    key: 'release',\n    value: function release() {\n\n      // Unbinding events\n      this.tree.off('write', this.writeListener);\n      this.tree.off('_monkey', this.recursiveListener);\n      this.state.killed = true;\n\n      // Deleting properties\n      // NOTE: not deleting this.definition because some strange things happen\n      // in the _refreshMonkeys method. See #372.\n      delete this.projection;\n      delete this.depPaths;\n      delete this.tree;\n    }\n  }]);\n\n  return Monkey;\n})();\n\nexports.Monkey = Monkey;","/home/travis/build/npmtest/node-npmtest-baobab/node_modules/baobab/dist/type.js":"/**\n * Baobab Type Checking\n * =====================\n *\n * Helpers functions used throughout the library to perform some type\n * tests at runtime.\n *\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _monkey = require('./monkey');\n\nvar type = {};\n\n/**\n * Helpers\n * --------\n */\n\n/**\n * Checking whether the given variable is of any of the given types.\n *\n * @todo   Optimize this function by dropping `some`.\n *\n * @param  {mixed} target  - Variable to test.\n * @param  {array} allowed - Array of allowed types.\n * @return {boolean}\n */\nfunction anyOf(target, allowed) {\n  return allowed.some(function (t) {\n    return type[t](target);\n  });\n}\n\n/**\n * Simple types\n * -------------\n */\n\n/**\n * Checking whether the given variable is an array.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.array = function (target) {\n  return Array.isArray(target);\n};\n\n/**\n * Checking whether the given variable is an object.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.object = function (target) {\n  return target && typeof target === 'object' && !Array.isArray(target) && !(target instanceof Date) && !(target instanceof RegExp) && !(typeof Map === 'function' && target instanceof Map) && !(typeof Set === 'function' && target instanceof Set);\n};\n\n/**\n * Checking whether the given variable is a string.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.string = function (target) {\n  return typeof target === 'string';\n};\n\n/**\n * Checking whether the given variable is a number.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.number = function (target) {\n  return typeof target === 'number';\n};\n\n/**\n * Checking whether the given variable is a function.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype['function'] = function (target) {\n  return typeof target === 'function';\n};\n\n/**\n * Checking whether the given variable is a JavaScript primitive.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.primitive = function (target) {\n  return target !== Object(target);\n};\n\n/**\n * Complex types\n * --------------\n */\n\n/**\n * Checking whether the given variable is a valid splicer.\n *\n * @param  {mixed} target    - Variable to test.\n * @param  {array} [allowed] - Optional valid types in path.\n * @return {boolean}\n */\ntype.splicer = function (target) {\n  if (!type.array(target) || target.length < 1) return false;\n  if (target.length > 1 && isNaN(+target[1])) return false;\n\n  return anyOf(target[0], ['number', 'function', 'object']);\n};\n\n/**\n * Checking whether the given variable is a valid cursor path.\n *\n * @param  {mixed} target    - Variable to test.\n * @param  {array} [allowed] - Optional valid types in path.\n * @return {boolean}\n */\n\n// Order is important for performance reasons\nvar ALLOWED_FOR_PATH = ['string', 'number', 'function', 'object'];\n\ntype.path = function (target) {\n  if (!target && target !== 0 && target !== '') return false;\n\n  return [].concat(target).every(function (step) {\n    return anyOf(step, ALLOWED_FOR_PATH);\n  });\n};\n\n/**\n * Checking whether the given path is a dynamic one.\n *\n * @param  {mixed} path - The path to test.\n * @return {boolean}\n */\ntype.dynamicPath = function (path) {\n  return path.some(function (step) {\n    return type['function'](step) || type.object(step);\n  });\n};\n\n/**\n * Retrieve any monkey subpath in the given path or null if the path never comes\n * across computed data.\n *\n * @param  {mixed} data - The data to test.\n * @param  {array} path - The path to test.\n * @return {boolean}\n */\ntype.monkeyPath = function (data, path) {\n  var subpath = [];\n\n  var c = data,\n      i = undefined,\n      l = undefined;\n\n  for (i = 0, l = path.length; i < l; i++) {\n    subpath.push(path[i]);\n\n    if (typeof c !== 'object') return null;\n\n    c = c[path[i]];\n\n    if (c instanceof _monkey.Monkey) return subpath;\n  }\n\n  return null;\n};\n\n/**\n * Check if the given object property is a lazy getter used by a monkey.\n *\n * @param  {mixed}   o           - The target object.\n * @param  {string}  propertyKey - The property to test.\n * @return {boolean}\n */\ntype.lazyGetter = function (o, propertyKey) {\n  var descriptor = Object.getOwnPropertyDescriptor(o, propertyKey);\n\n  return descriptor && descriptor.get && descriptor.get.isLazyGetter === true;\n};\n\n/**\n * Returns the type of the given monkey definition or `null` if invalid.\n *\n * @param  {mixed} definition - The definition to check.\n * @return {string|null}\n */\ntype.monkeyDefinition = function (definition) {\n\n  if (type.object(definition)) {\n    if (!type['function'](definition.get) || definition.cursors && (!type.object(definition.cursors) || !Object.keys(definition.cursors).every(function (k) {\n      return type.path(definition.cursors[k]);\n    }))) return null;\n\n    return 'object';\n  } else if (type.array(definition)) {\n    var offset = 1;\n\n    if (type.object(definition[definition.length - 1])) offset++;\n\n    if (!type['function'](definition[definition.length - offset]) || !definition.slice(0, -offset).every(function (p) {\n      return type.path(p);\n    })) return null;\n\n    return 'array';\n  }\n\n  return null;\n};\n\n/**\n * Checking whether the given watcher definition is valid.\n *\n * @param  {mixed}   definition - The definition to check.\n * @return {boolean}\n */\ntype.watcherMapping = function (definition) {\n  return type.object(definition) && Object.keys(definition).every(function (k) {\n    return type.path(definition[k]);\n  });\n};\n\n/**\n * Checking whether the given string is a valid operation type.\n *\n * @param  {mixed} string - The string to test.\n * @return {boolean}\n */\n\n// Ordered by likeliness\nvar VALID_OPERATIONS = ['set', 'apply', 'push', 'unshift', 'concat', 'pop', 'shift', 'deepMerge', 'merge', 'splice', 'unset'];\n\ntype.operationType = function (string) {\n  return typeof string === 'string' && !! ~VALID_OPERATIONS.indexOf(string);\n};\n\nexports['default'] = type;\nmodule.exports = exports['default'];","/home/travis/build/npmtest/node-npmtest-baobab/node_modules/baobab/dist/update.js":"/**\n * Baobab Update\n * ==============\n *\n * The tree's update scheme.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports['default'] = update;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\nvar _type = require('./type');\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _helpers = require('./helpers');\n\nfunction err(operation, expectedTarget, path) {\n  return (0, _helpers.makeError)('Baobab.update: cannot apply the \"' + operation + '\" on ' + ('a non ' + expectedTarget + ' (path: /' + path.join('/') + ').'), { path: path });\n}\n\n/**\n * Function aiming at applying a single update operation on the given tree's\n * data.\n *\n * @param  {mixed}  data      - The tree's data.\n * @param  {path}   path      - Path of the update.\n * @param  {object} operation - The operation to apply.\n * @param  {object} [opts]    - Optional options.\n * @return {mixed}            - Both the new tree's data and the updated node.\n */\n\nfunction update(data, path, operation) {\n  var opts = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n  var operationType = operation.type;\n  var value = operation.value;\n  var _operation$options = operation.options;\n  var operationOptions = _operation$options === undefined ? {} : _operation$options;\n\n  // Dummy root, so we can shift and alter the root\n  var dummy = { root: data },\n      dummyPath = ['root'].concat(_toConsumableArray(path)),\n      currentPath = [];\n\n  // Walking the path\n  var p = dummy,\n      i = undefined,\n      l = undefined,\n      s = undefined;\n\n  for (i = 0, l = dummyPath.length; i < l; i++) {\n\n    // Current item's reference is therefore p[s]\n    // The reason why we don't create a variable here for convenience\n    // is because we actually need to mutate the reference.\n    s = dummyPath[i];\n\n    // Updating the path\n    if (i > 0) currentPath.push(s);\n\n    // If we reached the end of the path, we apply the operation\n    if (i === l - 1) {\n\n      /**\n       * Set\n       */\n      if (operationType === 'set') {\n\n        // Purity check\n        if (opts.pure && p[s] === value) return { node: p[s] };\n\n        if (_type2['default'].lazyGetter(p, s)) {\n          Object.defineProperty(p, s, {\n            value: value,\n            enumerable: true,\n            configurable: true\n          });\n        } else if (opts.persistent && !operationOptions.mutableLeaf) {\n          p[s] = (0, _helpers.shallowClone)(value);\n        } else {\n          p[s] = value;\n        }\n      }\n\n      /**\n       * Monkey\n       */\n      else if (operationType === 'monkey') {\n          Object.defineProperty(p, s, {\n            get: value,\n            enumerable: true,\n            configurable: true\n          });\n        }\n\n        /**\n         * Apply\n         */\n        else if (operationType === 'apply') {\n            var result = value(p[s]);\n\n            // Purity check\n            if (opts.pure && p[s] === result) return { node: p[s] };\n\n            if (_type2['default'].lazyGetter(p, s)) {\n              Object.defineProperty(p, s, {\n                value: result,\n                enumerable: true,\n                configurable: true\n              });\n            } else if (opts.persistent) {\n              p[s] = (0, _helpers.shallowClone)(result);\n            } else {\n              p[s] = result;\n            }\n          }\n\n          /**\n           * Push\n           */\n          else if (operationType === 'push') {\n              if (!_type2['default'].array(p[s])) throw err('push', 'array', currentPath);\n\n              if (opts.persistent) p[s] = p[s].concat([value]);else p[s].push(value);\n            }\n\n            /**\n             * Unshift\n             */\n            else if (operationType === 'unshift') {\n                if (!_type2['default'].array(p[s])) throw err('unshift', 'array', currentPath);\n\n                if (opts.persistent) p[s] = [value].concat(p[s]);else p[s].unshift(value);\n              }\n\n              /**\n               * Concat\n               */\n              else if (operationType === 'concat') {\n                  if (!_type2['default'].array(p[s])) throw err('concat', 'array', currentPath);\n\n                  if (opts.persistent) p[s] = p[s].concat(value);else p[s].push.apply(p[s], value);\n                }\n\n                /**\n                 * Splice\n                 */\n                else if (operationType === 'splice') {\n                    if (!_type2['default'].array(p[s])) throw err('splice', 'array', currentPath);\n\n                    if (opts.persistent) p[s] = _helpers.splice.apply(null, [p[s]].concat(value));else p[s].splice.apply(p[s], value);\n                  }\n\n                  /**\n                   * Pop\n                   */\n                  else if (operationType === 'pop') {\n                      if (!_type2['default'].array(p[s])) throw err('pop', 'array', currentPath);\n\n                      if (opts.persistent) p[s] = (0, _helpers.splice)(p[s], -1, 1);else p[s].pop();\n                    }\n\n                    /**\n                     * Shift\n                     */\n                    else if (operationType === 'shift') {\n                        if (!_type2['default'].array(p[s])) throw err('shift', 'array', currentPath);\n\n                        if (opts.persistent) p[s] = (0, _helpers.splice)(p[s], 0, 1);else p[s].shift();\n                      }\n\n                      /**\n                       * Unset\n                       */\n                      else if (operationType === 'unset') {\n                          if (_type2['default'].object(p)) delete p[s];else if (_type2['default'].array(p)) p.splice(s, 1);\n                        }\n\n                        /**\n                         * Merge\n                         */\n                        else if (operationType === 'merge') {\n                            if (!_type2['default'].object(p[s])) throw err('merge', 'object', currentPath);\n\n                            if (opts.persistent) p[s] = (0, _helpers.shallowMerge)({}, p[s], value);else p[s] = (0, _helpers.shallowMerge)(p[s], value);\n                          }\n\n                          /**\n                           * Deep merge\n                           */\n                          else if (operationType === 'deepMerge') {\n                              if (!_type2['default'].object(p[s])) throw err('deepMerge', 'object', currentPath);\n\n                              if (opts.persistent) p[s] = (0, _helpers.deepMerge)({}, p[s], value);else p[s] = (0, _helpers.deepMerge)(p[s], value);\n                            }\n\n      // Deep freezing the resulting value\n      if (opts.immutable && !operationOptions.mutableLeaf) (0, _helpers.deepFreeze)(p);\n\n      break;\n    }\n\n    // If we reached a leaf, we override by setting an empty object\n    else if (_type2['default'].primitive(p[s])) {\n        p[s] = {};\n      }\n\n      // Else, we shift the reference and continue the path\n      else if (opts.persistent) {\n          p[s] = (0, _helpers.shallowClone)(p[s]);\n        }\n\n    // Should we freeze the current step before continuing?\n    if (opts.immutable && l > 0) (0, _helpers.freeze)(p);\n\n    p = p[s];\n  }\n\n  // If we are updating a dynamic node, we need not return the affected node\n  if (_type2['default'].lazyGetter(p, s)) return { data: dummy.root };\n\n  // Returning new data object\n  return { data: dummy.root, node: p[s] };\n}\n\nmodule.exports = exports['default'];","/home/travis/build/npmtest/node-npmtest-baobab/node_modules/baobab/dist/helpers.js":"/* eslint eqeqeq: 0 */\n\n/**\n * Baobab Helpers\n * ===============\n *\n * Miscellaneous helper functions.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nexports.arrayFrom = arrayFrom;\nexports.before = before;\nexports.coercePath = coercePath;\nexports.getIn = getIn;\nexports.makeError = makeError;\nexports.solveRelativePath = solveRelativePath;\nexports.solveUpdate = solveUpdate;\nexports.splice = splice;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _monkey = require('./monkey');\n\nvar _type = require('./type');\n\nvar _type2 = _interopRequireDefault(_type);\n\n/**\n * Noop function\n */\nvar noop = Function.prototype;\n\nvar hasOwnProp = ({}).hasOwnProperty;\n\n/**\n * Function returning the index of the first element of a list matching the\n * given predicate.\n *\n * @param  {array}     a  - The target array.\n * @param  {function}  fn - The predicate function.\n * @return {mixed}        - The index of the first matching item or -1.\n */\nfunction index(a, fn) {\n  var i = undefined,\n      l = undefined;\n  for (i = 0, l = a.length; i < l; i++) {\n    if (fn(a[i])) return i;\n  }\n  return -1;\n}\n\n/**\n * Efficient slice function used to clone arrays or parts of them.\n *\n * @param  {array} array - The array to slice.\n * @return {array}       - The sliced array.\n */\nfunction slice(array) {\n  var newArray = new Array(array.length);\n\n  var i = undefined,\n      l = undefined;\n\n  for (i = 0, l = array.length; i < l; i++) newArray[i] = array[i];\n\n  return newArray;\n}\n\n/**\n * Archive abstraction\n *\n * @constructor\n * @param {integer} size - Maximum number of records to store.\n */\n\nvar Archive = (function () {\n  function Archive(size) {\n    _classCallCheck(this, Archive);\n\n    this.size = size;\n    this.records = [];\n  }\n\n  /**\n   * Function creating a real array from what should be an array but is not.\n   * I'm looking at you nasty `arguments`...\n   *\n   * @param  {mixed} culprit - The culprit to convert.\n   * @return {array}         - The real array.\n   */\n\n  /**\n   * Method retrieving the records.\n   *\n   * @return {array} - The records.\n   */\n\n  _createClass(Archive, [{\n    key: 'get',\n    value: function get() {\n      return this.records;\n    }\n\n    /**\n     * Method adding a record to the archive\n     *\n     * @param {object}  record - The record to store.\n     * @return {Archive}       - The archive itself for chaining purposes.\n     */\n  }, {\n    key: 'add',\n    value: function add(record) {\n      this.records.unshift(record);\n\n      // If the number of records is exceeded, we truncate the records\n      if (this.records.length > this.size) this.records.length = this.size;\n\n      return this;\n    }\n\n    /**\n     * Method clearing the records.\n     *\n     * @return {Archive} - The archive itself for chaining purposes.\n     */\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this.records = [];\n      return this;\n    }\n\n    /**\n     * Method to go back in time.\n     *\n     * @param {integer} steps - Number of steps we should go back by.\n     * @return {number}       - The last record.\n     */\n  }, {\n    key: 'back',\n    value: function back(steps) {\n      var record = this.records[steps - 1];\n\n      if (record) this.records = this.records.slice(steps);\n      return record;\n    }\n  }]);\n\n  return Archive;\n})();\n\nexports.Archive = Archive;\n\nfunction arrayFrom(culprit) {\n  return slice(culprit);\n}\n\n/**\n * Function decorating one function with another that will be called before the\n * decorated one.\n *\n * @param  {function} decorator - The decorating function.\n * @param  {function} fn        - The function to decorate.\n * @return {function}           - The decorated function.\n */\n\nfunction before(decorator, fn) {\n  return function () {\n    decorator.apply(null, arguments);\n    fn.apply(null, arguments);\n  };\n}\n\n/**\n * Function cloning the given regular expression. Supports `y` and `u` flags\n * already.\n *\n * @param  {RegExp} re - The target regular expression.\n * @return {RegExp}    - The cloned regular expression.\n */\nfunction cloneRegexp(re) {\n  var pattern = re.source;\n\n  var flags = '';\n\n  if (re.global) flags += 'g';\n  if (re.multiline) flags += 'm';\n  if (re.ignoreCase) flags += 'i';\n  if (re.sticky) flags += 'y';\n  if (re.unicode) flags += 'u';\n\n  return new RegExp(pattern, flags);\n}\n\n/**\n * Function cloning the given variable.\n *\n * @todo: implement a faster way to clone an array.\n *\n * @param  {boolean} deep - Should we deep clone the variable.\n * @param  {mixed}   item - The variable to clone\n * @return {mixed}        - The cloned variable.\n */\nfunction cloner(deep, item) {\n  if (!item || typeof item !== 'object' || item instanceof Error || item instanceof _monkey.MonkeyDefinition || item instanceof _monkey.Monkey || 'ArrayBuffer' in global && item instanceof ArrayBuffer) return item;\n\n  // Array\n  if (_type2['default'].array(item)) {\n    if (deep) {\n      var a = [];\n\n      var i = undefined,\n          l = undefined;\n\n      for (i = 0, l = item.length; i < l; i++) a.push(cloner(true, item[i]));\n      return a;\n    }\n\n    return slice(item);\n  }\n\n  // Date\n  if (item instanceof Date) return new Date(item.getTime());\n\n  // RegExp\n  if (item instanceof RegExp) return cloneRegexp(item);\n\n  // Object\n  if (_type2['default'].object(item)) {\n    var o = {};\n\n    var i = undefined,\n        l = undefined,\n        k = undefined;\n\n    // NOTE: could be possible to erase computed properties through `null`.\n    var props = Object.getOwnPropertyNames(item);\n    for (i = 0, l = props.length; i < l; i++) {\n      k = props[i];\n      if (_type2['default'].lazyGetter(item, k)) {\n        Object.defineProperty(o, k, {\n          get: Object.getOwnPropertyDescriptor(item, k).get,\n          enumerable: true,\n          configurable: true\n        });\n      } else {\n        Object.defineProperty(o, k, {\n          value: deep ? cloner(true, item[k]) : item[k],\n          enumerable: Object.getOwnPropertyDescriptor(item, k).enumerable,\n          writable: true,\n          configurable: true\n        });\n      }\n    }\n    return o;\n  }\n\n  return item;\n}\n\n/**\n * Exporting shallow and deep cloning functions.\n */\nvar shallowClone = cloner.bind(null, false),\n    deepClone = cloner.bind(null, true);\n\nexports.shallowClone = shallowClone;\nexports.deepClone = deepClone;\n\n/**\n * Coerce the given variable into a full-fledged path.\n *\n * @param  {mixed} target - The variable to coerce.\n * @return {array}        - The array path.\n */\n\nfunction coercePath(target) {\n  if (target || target === 0 || target === '') return target;\n  return [];\n}\n\n/**\n * Function comparing an object's properties to a given descriptive\n * object.\n *\n * @param  {object} object      - The object to compare.\n * @param  {object} description - The description's mapping.\n * @return {boolean}            - Whether the object matches the description.\n */\nfunction compare(object, description) {\n  var ok = true,\n      k = undefined;\n\n  // If we reached here via a recursive call, object may be undefined because\n  // not all items in a collection will have the same deep nesting structure.\n  if (!object) return false;\n\n  for (k in description) {\n    if (_type2['default'].object(description[k])) {\n      ok = ok && compare(object[k], description[k]);\n    } else if (_type2['default'].array(description[k])) {\n      ok = ok && !! ~description[k].indexOf(object[k]);\n    } else {\n      if (object[k] !== description[k]) return false;\n    }\n  }\n\n  return ok;\n}\n\n/**\n * Function freezing the given variable if possible.\n *\n * @param  {boolean} deep - Should we recursively freeze the given objects?\n * @param  {object}  o    - The variable to freeze.\n * @return {object}    - The merged object.\n */\nfunction freezer(deep, o) {\n  if (typeof o !== 'object' || o === null || o instanceof _monkey.Monkey) return;\n\n  Object.freeze(o);\n\n  if (!deep) return;\n\n  if (Array.isArray(o)) {\n\n    // Iterating through the elements\n    var i = undefined,\n        l = undefined;\n\n    for (i = 0, l = o.length; i < l; i++) freezer(true, o[i]);\n  } else {\n    var p = undefined,\n        k = undefined;\n\n    for (k in o) {\n      if (_type2['default'].lazyGetter(o, k)) continue;\n\n      p = o[k];\n\n      if (!p || !hasOwnProp.call(o, k) || typeof p !== 'object' || Object.isFrozen(p)) continue;\n\n      freezer(true, p);\n    }\n  }\n}\n\n/**\n * Exporting both `freeze` and `deepFreeze` functions.\n * Note that if the engine does not support `Object.freeze` then this will\n * export noop functions instead.\n */\nvar isFreezeSupported = typeof Object.freeze === 'function';\n\nvar freeze = isFreezeSupported ? freezer.bind(null, false) : noop,\n    deepFreeze = isFreezeSupported ? freezer.bind(null, true) : noop;\n\nexports.freeze = freeze;\nexports.deepFreeze = deepFreeze;\n\n/**\n * Function retrieving nested data within the given object and according to\n * the given path.\n *\n * @todo: work if dynamic path hit objects also.\n * @todo: memoized perfgetters.\n *\n * @param  {object}  object - The object we need to get data from.\n * @param  {array}   path   - The path to follow.\n * @return {object}  result            - The result.\n * @return {mixed}   result.data       - The data at path, or `undefined`.\n * @return {array}   result.solvedPath - The solved path or `null`.\n * @return {boolean} result.exists     - Does the path exists in the tree?\n */\nvar NOT_FOUND_OBJECT = { data: undefined, solvedPath: null, exists: false };\n\nfunction getIn(object, path) {\n  if (!path) return NOT_FOUND_OBJECT;\n\n  var solvedPath = [];\n\n  var exists = true,\n      c = object,\n      idx = undefined,\n      i = undefined,\n      l = undefined;\n\n  for (i = 0, l = path.length; i < l; i++) {\n    if (!c) return {\n      data: undefined,\n      solvedPath: solvedPath.concat(path.slice(i)),\n      exists: false\n    };\n\n    if (typeof path[i] === 'function') {\n      if (!_type2['default'].array(c)) return NOT_FOUND_OBJECT;\n\n      idx = index(c, path[i]);\n      if (! ~idx) return NOT_FOUND_OBJECT;\n\n      solvedPath.push(idx);\n      c = c[idx];\n    } else if (typeof path[i] === 'object') {\n      if (!_type2['default'].array(c)) return NOT_FOUND_OBJECT;\n\n      idx = index(c, function (e) {\n        return compare(e, path[i]);\n      });\n      if (! ~idx) return NOT_FOUND_OBJECT;\n\n      solvedPath.push(idx);\n      c = c[idx];\n    } else {\n      solvedPath.push(path[i]);\n      exists = typeof c === 'object' && path[i] in c;\n      c = c[path[i]];\n    }\n  }\n\n  return { data: c, solvedPath: solvedPath, exists: exists };\n}\n\n/**\n * Little helper returning a JavaScript error carrying some data with it.\n *\n * @param  {string} message - The error message.\n * @param  {object} [data]  - Optional data to assign to the error.\n * @return {Error}          - The created error.\n */\n\nfunction makeError(message, data) {\n  var err = new Error(message);\n\n  for (var k in data) {\n    err[k] = data[k];\n  }return err;\n}\n\n/**\n * Function taking n objects to merge them together.\n * Note 1): the latter object will take precedence over the first one.\n * Note 2): the first object will be mutated to allow for perf scenarios.\n * Note 3): this function will consider monkeys as leaves.\n *\n * @param  {boolean}   deep    - Whether the merge should be deep or not.\n * @param  {...object} objects - Objects to merge.\n * @return {object}            - The merged object.\n */\nfunction merger(deep) {\n  for (var _len = arguments.length, objects = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    objects[_key - 1] = arguments[_key];\n  }\n\n  var o = objects[0];\n\n  var t = undefined,\n      i = undefined,\n      l = undefined,\n      k = undefined;\n\n  for (i = 1, l = objects.length; i < l; i++) {\n    t = objects[i];\n\n    for (k in t) {\n      if (deep && _type2['default'].object(t[k]) && !(t[k] instanceof _monkey.Monkey)) {\n        o[k] = merger(true, o[k] || {}, t[k]);\n      } else {\n        o[k] = t[k];\n      }\n    }\n  }\n\n  return o;\n}\n\n/**\n * Exporting both `shallowMerge` and `deepMerge` functions.\n */\nvar shallowMerge = merger.bind(null, false),\n    deepMerge = merger.bind(null, true);\n\nexports.shallowMerge = shallowMerge;\nexports.deepMerge = deepMerge;\n\n/**\n * Solving a potentially relative path.\n *\n * @param  {array} base - The base path from which to solve the path.\n * @param  {array} to   - The subpath to reach.\n * @param  {array}      - The solved absolute path.\n */\n\nfunction solveRelativePath(base, to) {\n  var solvedPath = [];\n\n  // Coercing to array\n  to = [].concat(to);\n\n  for (var i = 0, l = to.length; i < l; i++) {\n    var step = to[i];\n\n    if (step === '.') {\n      if (!i) solvedPath = base.slice(0);\n    } else if (step === '..') {\n      solvedPath = (!i ? base : solvedPath).slice(0, -1);\n    } else {\n      solvedPath.push(step);\n    }\n  }\n\n  return solvedPath;\n}\n\n/**\n * Function determining whether some paths in the tree were affected by some\n * updates that occurred at the given paths. This helper is mainly used at\n * cursor level to determine whether the cursor is concerned by the updates\n * fired at tree level.\n *\n * NOTES: 1) If performance become an issue, the following threefold loop\n *           can be simplified to a complex twofold one.\n *        2) A regex version could also work but I am not confident it would\n *           be faster.\n *        3) Another solution would be to keep a register of cursors like with\n *           the monkeys and update along this tree.\n *\n * @param  {array} affectedPaths - The paths that were updated.\n * @param  {array} comparedPaths - The paths that we are actually interested in.\n * @return {boolean}             - Is the update relevant to the compared\n *                                 paths?\n */\n\nfunction solveUpdate(affectedPaths, comparedPaths) {\n  var i = undefined,\n      j = undefined,\n      k = undefined,\n      l = undefined,\n      m = undefined,\n      n = undefined,\n      p = undefined,\n      c = undefined,\n      s = undefined;\n\n  // Looping through possible paths\n  for (i = 0, l = affectedPaths.length; i < l; i++) {\n    p = affectedPaths[i];\n\n    if (!p.length) return true;\n\n    // Looping through logged paths\n    for (j = 0, m = comparedPaths.length; j < m; j++) {\n      c = comparedPaths[j];\n\n      if (!c || !c.length) return true;\n\n      // Looping through steps\n      for (k = 0, n = c.length; k < n; k++) {\n        s = c[k];\n\n        // If path is not relevant, we break\n        // NOTE: the '!=' instead of '!==' is required here!\n        if (s != p[k]) break;\n\n        // If we reached last item and we are relevant\n        if (k + 1 === n || k + 1 === p.length) return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Non-mutative version of the splice array method.\n *\n * @param  {array}    array        - The array to splice.\n * @param  {integer}  startIndex   - The start index.\n * @param  {integer}  nb           - Number of elements to remove.\n * @param  {...mixed} elements     - Elements to append after splicing.\n * @return {array}                 - The spliced array.\n */\n\nfunction splice(array, startIndex, nb) {\n  for (var _len2 = arguments.length, elements = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n    elements[_key2 - 3] = arguments[_key2];\n  }\n\n  if (nb === undefined && arguments.length === 2) nb = array.length - startIndex;else if (nb === null || nb === undefined) nb = 0;else if (isNaN(+nb)) throw new Error('argument nb ' + nb + ' can not be parsed into a number!');\n  nb = Math.max(0, nb);\n\n  // Solving startIndex\n  if (_type2['default']['function'](startIndex)) startIndex = index(array, startIndex);\n  if (_type2['default'].object(startIndex)) startIndex = index(array, function (e) {\n    return compare(e, startIndex);\n  });\n\n  // Positive index\n  if (startIndex >= 0) return array.slice(0, startIndex).concat(elements).concat(array.slice(startIndex + nb));\n\n  // Negative index\n  return array.slice(0, array.length + startIndex).concat(elements).concat(array.slice(array.length + startIndex + nb));\n}\n\n/**\n * Function returning a unique incremental id each time it is called.\n *\n * @return {integer} - The latest unique id.\n */\nvar uniqid = (function () {\n  var i = 0;\n\n  return function () {\n    return i++;\n  };\n})();\n\nexports.uniqid = uniqid;","/home/travis/build/npmtest/node-npmtest-baobab/node_modules/baobab/dist/watcher.js":"/**\n * Baobab Watchers\n * ================\n *\n * Abstraction used to listen and retrieve data from multiple parts of a\n * Baobab tree at once.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _emmett = require('emmett');\n\nvar _emmett2 = _interopRequireDefault(_emmett);\n\nvar _cursor = require('./cursor');\n\nvar _cursor2 = _interopRequireDefault(_cursor);\n\nvar _type = require('./type');\n\nvar _type2 = _interopRequireDefault(_type);\n\nvar _helpers = require('./helpers');\n\n/**\n * Watcher class.\n *\n * @constructor\n * @param {Baobab} tree     - The watched tree.\n * @param {object} mapping  - A mapping of the paths to watch in the tree.\n */\n\nvar Watcher = (function (_Emitter) {\n  _inherits(Watcher, _Emitter);\n\n  function Watcher(tree, mapping) {\n    var _this = this;\n\n    _classCallCheck(this, Watcher);\n\n    _get(Object.getPrototypeOf(Watcher.prototype), 'constructor', this).call(this);\n\n    // Properties\n    this.tree = tree;\n    this.mapping = null;\n\n    this.state = {\n      killed: false\n    };\n\n    // Initializing\n    this.refresh(mapping);\n\n    // Listening\n    this.handler = function (e) {\n      if (_this.state.killed) return;\n\n      var watchedPaths = _this.getWatchedPaths();\n\n      if ((0, _helpers.solveUpdate)(e.data.paths, watchedPaths)) return _this.emit('update');\n    };\n\n    this.tree.on('update', this.handler);\n  }\n\n  /**\n   * Method used to get the current watched paths.\n   *\n   * @return {array} - The array of watched paths.\n   */\n\n  _createClass(Watcher, [{\n    key: 'getWatchedPaths',\n    value: function getWatchedPaths() {\n      var _this2 = this;\n\n      var rawPaths = Object.keys(this.mapping).map(function (k) {\n        var v = _this2.mapping[k];\n\n        // Watcher mappings can accept a cursor\n        if (v instanceof _cursor2['default']) return v.solvedPath;\n\n        return _this2.mapping[k];\n      });\n\n      return rawPaths.reduce(function (cp, p) {\n\n        // Handling path polymorphisms\n        p = [].concat(p);\n\n        // Dynamic path?\n        if (_type2['default'].dynamicPath(p)) p = (0, _helpers.getIn)(_this2.tree._data, p).solvedPath;\n\n        if (!p) return cp;\n\n        // Facet path?\n        var monkeyPath = _type2['default'].monkeyPath(_this2.tree._monkeys, p);\n\n        if (monkeyPath) return cp.concat((0, _helpers.getIn)(_this2.tree._monkeys, monkeyPath).data.relatedPaths());\n\n        return cp.concat([p]);\n      }, []);\n    }\n\n    /**\n     * Method used to return a map of the watcher's cursors.\n     *\n     * @return {object} - TMap of relevant cursors.\n     */\n  }, {\n    key: 'getCursors',\n    value: function getCursors() {\n      var _this3 = this;\n\n      var cursors = {};\n\n      Object.keys(this.mapping).forEach(function (k) {\n        var path = _this3.mapping[k];\n\n        if (path instanceof _cursor2['default']) cursors[k] = path;else cursors[k] = _this3.tree.select(path);\n      });\n\n      return cursors;\n    }\n\n    /**\n     * Method used to refresh the watcher's mapping.\n     *\n     * @param  {object}  mapping  - The new mapping to apply.\n     * @return {Watcher}          - Itself for chaining purposes.\n     */\n  }, {\n    key: 'refresh',\n    value: function refresh(mapping) {\n\n      if (!_type2['default'].watcherMapping(mapping)) throw (0, _helpers.makeError)('Baobab.watch: invalid mapping.', { mapping: mapping });\n\n      this.mapping = mapping;\n\n      // Creating the get method\n      var projection = {};\n\n      for (var k in mapping) {\n        projection[k] = mapping[k] instanceof _cursor2['default'] ? mapping[k].path : mapping[k];\n      }this.get = this.tree.project.bind(this.tree, projection);\n    }\n\n    /**\n     * Methods releasing the watcher from memory.\n     */\n  }, {\n    key: 'release',\n    value: function release() {\n\n      this.tree.off('update', this.handler);\n      this.state.killed = true;\n      this.kill();\n    }\n  }]);\n\n  return Watcher;\n})(_emmett2['default']);\n\nexports['default'] = Watcher;\nmodule.exports = exports['default'];","/home/travis/build/npmtest/node-npmtest-baobab/node_modules/baobab/eslint.config.js":"module.exports = {\n  extends: [\n    '@yomguithereal/eslint-config/es6'\n  ].map(require.resolve),\n  rules: {\n    'no-loop-func': 0\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-baobab/node_modules/baobab/scripts/banner.js":"var banner = require('add-banner'),\n    path = require('path'),\n    fs = require('fs');\n\nvar builtPath = path.join(__dirname, '..', 'build', 'baobab.js'),\n    minifiedPath = path.join(__dirname, '..', 'build', 'baobab.min.js');\n\nvar built = fs.readFileSync(builtPath, 'utf-8'),\n    minified = fs.readFileSync(minifiedPath, 'utf-8');\n\nvar options = {\n  banner: path.join(__dirname, 'banner.tmpl'),\n  name: 'Baobab'\n};\n\nfs.writeFileSync(builtPath, banner(built, options));\nfs.writeFileSync(minifiedPath, banner(minified, options));\n","/home/travis/build/npmtest/node-npmtest-baobab/node_modules/baobab/src/baobab.js":"/**\n * Baobab Data Structure\n * ======================\n *\n * A handy data tree with cursors.\n */\nimport Emitter from 'emmett';\nimport Cursor from './cursor';\nimport {MonkeyDefinition, Monkey} from './monkey';\nimport Watcher from './watcher';\nimport type from './type';\nimport update from './update';\nimport * as helpers from './helpers';\n\nconst {\n  arrayFrom,\n  coercePath,\n  deepFreeze,\n  getIn,\n  makeError,\n  deepClone,\n  deepMerge,\n  shallowClone,\n  shallowMerge,\n  uniqid\n} = helpers;\n\n/**\n * Baobab defaults\n */\nconst DEFAULTS = {\n\n  // Should the tree handle its transactions on its own?\n  autoCommit: true,\n\n  // Should the transactions be handled asynchronously?\n  asynchronous: true,\n\n  // Should the tree's data be immutable?\n  immutable: true,\n\n  // Should the monkeys be lazy?\n  lazyMonkeys: true,\n\n  // Should the tree be persistent?\n  persistent: true,\n\n  // Should the tree's update be pure?\n  pure: true,\n\n  // Validation specifications\n  validate: null,\n\n  // Validation behavior 'rollback' or 'notify'\n  validationBehavior: 'rollback'\n};\n\n/**\n * Function returning a string hash from a non-dynamic path expressed as an\n * array.\n *\n * @param  {array}  path - The path to hash.\n * @return {string} string - The resultant hash.\n */\nfunction hashPath(path) {\n  return 'λ' + path.map(step => {\n    if (type.function(step) || type.object(step))\n      return `#${uniqid()}#`;\n\n    return step;\n  }).join('λ');\n}\n\n/**\n * Baobab class\n *\n * @constructor\n * @param {object|array} [initialData={}]    - Initial data passed to the tree.\n * @param {object}       [opts]              - Optional options.\n * @param {boolean}      [opts.autoCommit]   - Should the tree auto-commit?\n * @param {boolean}      [opts.asynchronous] - Should the tree's transactions\n *                                             handled asynchronously?\n * @param {boolean}      [opts.immutable]    - Should the tree be immutable?\n * @param {boolean}      [opts.persistent]   - Should the tree be persistent?\n * @param {boolean}      [opts.pure]         - Should the tree be pure?\n * @param {function}     [opts.validate]     - Validation function.\n * @param {string}       [opts.validationBehaviour] - \"rollback\" or \"notify\".\n */\nexport default class Baobab extends Emitter {\n  constructor(initialData, opts) {\n    super();\n\n    // Setting initialData to an empty object if no data is provided by use\n    if (arguments.length < 1)\n      initialData = {};\n\n    // Checking whether given initial data is valid\n    if (!type.object(initialData) && !type.array(initialData))\n      throw makeError('Baobab: invalid data.', {data: initialData});\n\n    // Merging given options with defaults\n    this.options = shallowMerge({}, DEFAULTS, opts);\n\n    // Disabling immutability & persistence if persistence if disabled\n    if (!this.options.persistent) {\n      this.options.immutable = false;\n      this.options.pure = false;\n    }\n\n    // Privates\n    this._identity = '[object Baobab]';\n    this._cursors = {};\n    this._future = null;\n    this._transaction = [];\n    this._affectedPathsIndex = {};\n    this._monkeys = {};\n    this._previousData = null;\n    this._data = initialData;\n\n    // Properties\n    this.root = new Cursor(this, [], 'λ');\n    delete this.root.release;\n\n    // Does the user want an immutable tree?\n    if (this.options.immutable)\n      deepFreeze(this._data);\n\n    // Bootstrapping root cursor's getters and setters\n    const bootstrap = (name) => {\n      this[name] = function() {\n        const r = this.root[name].apply(this.root, arguments);\n        return r instanceof Cursor ? this : r;\n      };\n    };\n\n    [\n      'apply',\n      'clone',\n      'concat',\n      'deepClone',\n      'deepMerge',\n      'exists',\n      'get',\n      'push',\n      'merge',\n      'pop',\n      'project',\n      'serialize',\n      'set',\n      'shift',\n      'splice',\n      'unset',\n      'unshift'\n    ].forEach(bootstrap);\n\n    // Registering the initial monkeys\n    this._refreshMonkeys();\n\n    // Initial validation\n    const validationError = this.validate();\n\n    if (validationError)\n      throw Error('Baobab: invalid data.', {error: validationError});\n  }\n\n  /**\n   * Internal method used to refresh the tree's monkey register on every\n   * update.\n   * Note 1) For the time being, placing monkeys beneath array nodes is not\n   * allowed for performance reasons.\n   *\n   * @param  {mixed}   node      - The starting node.\n   * @param  {array}   path      - The starting node's path.\n   * @param  {string}  operation - The operation that lead to a refreshment.\n   * @return {Baobab}            - The tree instance for chaining purposes.\n   */\n  _refreshMonkeys(node, path, operation) {\n\n    const clean = (data, p = []) => {\n      if (data instanceof Monkey) {\n        data.release();\n        update(this._monkeys, p, {type: 'unset'}, {\n          immutable: false,\n          persistent: false,\n          pure: false\n        });\n\n        return;\n      }\n\n      if (type.object(data)) {\n        for (const k in data)\n          clean(data[k], p.concat(k));\n      }\n    };\n\n    const walk = (data, p = []) => {\n\n      // Should we sit a monkey in the tree?\n      if (data instanceof MonkeyDefinition ||\n          data instanceof Monkey) {\n        const monkeyInstance = new Monkey(\n          this,\n          p,\n          data instanceof Monkey ? data.definition : data\n        );\n\n        update(this._monkeys, p, {type: 'set', value: monkeyInstance}, {\n          immutable: false,\n          persistent: false,\n          pure: false\n        });\n\n        return;\n      }\n\n      // Object iteration\n      if (type.object(data)) {\n        for (const k in data)\n          walk(data[k], p.concat(k));\n      }\n    };\n\n    // Walking the whole tree\n    if (!arguments.length) {\n      walk(this._data);\n    }\n    else {\n      const monkeysNode = getIn(this._monkeys, path).data;\n\n      // Is this required that we clean some already existing monkeys?\n      if (monkeysNode)\n        clean(monkeysNode, path);\n\n      // Let's walk the tree only from the updated point\n      if (operation !== 'unset') {\n        walk(node, path);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Method used to validate the tree's data.\n   *\n   * @return {boolean} - Is the tree valid?\n   */\n  validate(affectedPaths) {\n    const {validate, validationBehavior: behavior} = this.options;\n\n    if (typeof validate !== 'function')\n      return null;\n\n    const error = validate.call(\n      this,\n      this._previousData,\n      this._data,\n      affectedPaths || [[]]\n    );\n\n    if (error instanceof Error) {\n\n      if (behavior === 'rollback') {\n        this._data = this._previousData;\n        this._affectedPathsIndex = {};\n        this._transaction = [];\n        this._previousData = this._data;\n      }\n\n      this.emit('invalid', {error});\n\n      return error;\n    }\n\n    return null;\n  }\n\n  /**\n   * Method used to select data within the tree by creating a cursor. Cursors\n   * are kept as singletons by the tree for performance and hygiene reasons.\n   *\n   * Arity (1):\n   * @param {path}    path - Path to select in the tree.\n   *\n   * Arity (*):\n   * @param {...step} path - Path to select in the tree.\n   *\n   * @return {Cursor}      - The resultant cursor.\n   */\n  select(path) {\n\n    // If no path is given, we simply return the root\n    path = path || [];\n\n    // Variadic\n    if (arguments.length > 1)\n      path = arrayFrom(arguments);\n\n    // Checking that given path is valid\n    if (!type.path(path))\n      throw makeError('Baobab.select: invalid path.', {path});\n\n    // Casting to array\n    path = [].concat(path);\n\n    // Computing hash (done here because it would be too late to do it in the\n    // cursor's constructor since we need to hit the cursors' index first).\n    const hash = hashPath(path);\n\n    // Creating a new cursor or returning the already existing one for the\n    // requested path.\n    let cursor = this._cursors[hash];\n\n    if (!cursor) {\n      cursor = new Cursor(this, path, hash);\n      this._cursors[hash] = cursor;\n    }\n\n    // Emitting an event to notify that a part of the tree was selected\n    this.emit('select', {path, cursor});\n    return cursor;\n  }\n\n  /**\n   * Method used to update the tree. Updates are simply expressed by a path,\n   * dynamic or not, and an operation.\n   *\n   * This is where path solving should happen and not in the cursor.\n   *\n   * @param  {path}   path      - The path where we'll apply the operation.\n   * @param  {object} operation - The operation to apply.\n   * @return {mixed} - Return the result of the update.\n   */\n  update(path, operation) {\n\n    // Coercing path\n    path = coercePath(path);\n\n    if (!type.operationType(operation.type))\n      throw makeError(\n        `Baobab.update: unknown operation type \"${operation.type}\".`,\n        {operation}\n      );\n\n    // Solving the given path\n    const {solvedPath, exists} = getIn(\n      this._data,\n      path\n    );\n\n    // If we couldn't solve the path, we throw\n    if (!solvedPath)\n      throw makeError('Baobab.update: could not solve the given path.', {\n        path: solvedPath\n      });\n\n    // Read-only path?\n    const monkeyPath = type.monkeyPath(this._monkeys, solvedPath);\n    if (monkeyPath && solvedPath.length > monkeyPath.length)\n      throw makeError('Baobab.update: attempting to update a read-only path.', {\n        path: solvedPath\n      });\n\n    // We don't unset irrelevant paths\n    if (operation.type === 'unset' && !exists)\n      return;\n\n    // If we merge data, we need to acknowledge monkeys\n    let realOperation = operation;\n    if (/merge/i.test(operation.type)) {\n      const monkeysNode = getIn(this._monkeys, solvedPath).data;\n\n      if (type.object(monkeysNode)) {\n\n        // Cloning the operation not to create weird behavior for the user\n        realOperation = shallowClone(realOperation);\n\n        // Fetching the existing node in the current data\n        const currentNode = getIn(this._data, solvedPath).data;\n\n        if (/deep/i.test(realOperation.type))\n          realOperation.value = deepMerge({},\n            deepMerge({}, currentNode, deepClone(monkeysNode)),\n            realOperation.value\n          );\n        else\n          realOperation.value = shallowMerge({},\n            deepMerge({}, currentNode, deepClone(monkeysNode)),\n            realOperation.value\n          );\n      }\n    }\n\n    // Stashing previous data if this is the frame's first update\n    if (!this._transaction.length)\n      this._previousData = this._data;\n\n    // Applying the operation\n    const result = update(\n      this._data,\n      solvedPath,\n      realOperation,\n      this.options\n    );\n\n    const {data, node} = result;\n\n    // If because of purity, the update was moot, we stop here\n    if (!('data' in result))\n      return node;\n\n    // If the operation is push, the affected path is slightly different\n    const affectedPath = solvedPath.concat(\n      operation.type === 'push' ? node.length - 1 : []\n    );\n\n    const hash = hashPath(affectedPath);\n\n    // Updating data and transaction\n    this._data = data;\n    this._affectedPathsIndex[hash] = true;\n    this._transaction.push(shallowMerge({}, operation, {path: affectedPath}));\n\n    // Updating the monkeys\n    this._refreshMonkeys(node, solvedPath, operation.type);\n\n    // Emitting a `write` event\n    this.emit('write', {path: affectedPath});\n\n    // Should we let the user commit?\n    if (!this.options.autoCommit)\n      return node;\n\n    // Should we update asynchronously?\n    if (!this.options.asynchronous) {\n      this.commit();\n      return node;\n    }\n\n    // Updating asynchronously\n    if (!this._future)\n      this._future = setTimeout(() => this.commit(), 0);\n\n    // Finally returning the affected node\n    return node;\n  }\n\n  /**\n   * Method committing the updates of the tree and firing the tree's events.\n   *\n   * @return {Baobab} - The tree instance for chaining purposes.\n   */\n  commit() {\n\n    // Do not fire update if the transaction is empty\n    if (!this._transaction.length)\n      return this;\n\n    // Clearing timeout if one was defined\n    if (this._future)\n      this._future = clearTimeout(this._future);\n\n    const affectedPaths = Object.keys(this._affectedPathsIndex).map(h => {\n      return h !== 'λ' ?\n        h.split('λ').slice(1) :\n        [];\n    });\n\n    // Is the tree still valid?\n    const validationError = this.validate(affectedPaths);\n\n    if (validationError)\n      return this;\n\n    // Caching to keep original references before we change them\n    const transaction = this._transaction,\n          previousData = this._previousData;\n\n    this._affectedPathsIndex = {};\n    this._transaction = [];\n    this._previousData = this._data;\n\n    // Emitting update event\n    this.emit('update', {\n      paths: affectedPaths,\n      currentData: this._data,\n      transaction,\n      previousData\n    });\n\n    return this;\n  }\n\n  /**\n   * Method returning a monkey at the given path or else `null`.\n   *\n   * @param  {path}        path - Path of the monkey to retrieve.\n   * @return {Monkey|null}      - The Monkey instance of `null`.\n   */\n  getMonkey(path) {\n    path = coercePath(path);\n\n    const monkey = getIn(this._monkeys, [].concat(path)).data;\n\n    if (monkey instanceof Monkey)\n      return monkey;\n\n    return null;\n  }\n\n  /**\n   * Method used to watch a collection of paths within the tree. Very useful\n   * to bind UI components and such to the tree.\n   *\n   * @param  {object} mapping - Mapping of paths to listen.\n   * @return {Cursor}         - The created watcher.\n   */\n  watch(mapping) {\n    return new Watcher(this, mapping);\n  }\n\n  /**\n   * Method releasing the tree and its attached data from memory.\n   */\n  release() {\n    let k;\n\n    this.emit('release');\n\n    delete this.root;\n\n    delete this._data;\n    delete this._previousData;\n    delete this._transaction;\n    delete this._affectedPathsIndex;\n    delete this._monkeys;\n\n    // Releasing cursors\n    for (k in this._cursors)\n      this._cursors[k].release();\n    delete this._cursors;\n\n    // Killing event emitter\n    this.kill();\n  }\n\n  /**\n   * Overriding the `toJSON` method for convenient use with JSON.stringify.\n   *\n   * @return {mixed} - Data at cursor.\n   */\n  toJSON() {\n    return this.serialize();\n  }\n\n  /**\n   * Overriding the `toString` method for debugging purposes.\n   *\n   * @return {string} - The baobab's identity.\n   */\n  toString() {\n    return this._identity;\n  }\n}\n\n/**\n * Monkey helper.\n */\nBaobab.monkey = function(...args) {\n\n  if (!args.length)\n    throw new Error('Baobab.monkey: missing definition.');\n\n  if (args.length === 1 && typeof args[0] !== 'function')\n    return new MonkeyDefinition(args[0]);\n\n  return new MonkeyDefinition(args);\n};\nBaobab.dynamicNode = Baobab.monkey;\n\n/**\n * Exposing some internals for convenience\n */\nBaobab.Cursor = Cursor;\nBaobab.MonkeyDefinition = MonkeyDefinition;\nBaobab.Monkey = Monkey;\nBaobab.type = type;\nBaobab.helpers = helpers;\n\n/**\n * Version\n */\nBaobab.VERSION = '2.4.3';\n","/home/travis/build/npmtest/node-npmtest-baobab/node_modules/baobab/src/cursor.js":"/**\n * Baobab Cursors\n * ===============\n *\n * Cursors created by selecting some data within a Baobab tree.\n */\nimport Emitter from 'emmett';\nimport {Monkey} from './monkey';\nimport type from './type';\nimport {\n  Archive,\n  arrayFrom,\n  before,\n  coercePath,\n  deepClone,\n  getIn,\n  makeError,\n  shallowClone,\n  solveUpdate\n} from './helpers';\n\n\n/**\n * Traversal helper function for dynamic cursors. Will throw a legible error\n * if traversal is not possible.\n *\n * @param {string} method     - The method name, to create a correct error msg.\n * @param {array}  solvedPath - The cursor's solved path.\n */\nfunction checkPossibilityOfDynamicTraversal(method, solvedPath) {\n  if (!solvedPath)\n    throw makeError(\n      `Baobab.Cursor.${method}: ` +\n      `cannot use ${method} on an unresolved dynamic path.`,\n      {path: solvedPath}\n    );\n}\n\n/**\n * Cursor class\n *\n * @constructor\n * @param {Baobab} tree   - The cursor's root.\n * @param {array}  path   - The cursor's path in the tree.\n * @param {string} hash   - The path's hash computed ahead by the tree.\n */\nexport default class Cursor extends Emitter {\n  constructor(tree, path, hash) {\n    super();\n\n    // If no path were to be provided, we fallback to an empty path (root)\n    path = path || [];\n\n    // Privates\n    this._identity = '[object Cursor]';\n    this._archive = null;\n\n    // Properties\n    this.tree = tree;\n    this.path = path;\n    this.hash = hash;\n\n    // State\n    this.state = {\n      killed: false,\n      recording: false,\n      undoing: false\n    };\n\n    // Checking whether the given path is dynamic or not\n    this._dynamicPath = type.dynamicPath(this.path);\n\n    // Checking whether the given path will meet a monkey\n    this._monkeyPath = type.monkeyPath(this.tree._monkeys, this.path);\n\n    if (!this._dynamicPath)\n      this.solvedPath = this.path;\n    else\n      this.solvedPath = getIn(this.tree._data, this.path).solvedPath;\n\n    /**\n     * Listener bound to the tree's writes so that cursors with dynamic paths\n     * may update their solved path correctly.\n     *\n     * @param {object} event - The event fired by the tree.\n     */\n    this._writeHandler = ({data}) => {\n      if (this.state.killed ||\n          !solveUpdate([data.path], this._getComparedPaths()))\n        return;\n\n      this.solvedPath = getIn(this.tree._data, this.path).solvedPath;\n    };\n\n    /**\n     * Function in charge of actually trigger the cursor's updates and\n     * deal with the archived records.\n     *\n     * @note: probably should wrap the current solvedPath in closure to avoid\n     * for tricky cases where it would fail.\n     *\n     * @param {mixed} previousData - the tree's previous data.\n     */\n    const fireUpdate = (previousData) => {\n      const self = this;\n\n      const eventData = {\n        get previousData() {\n          return getIn(previousData, self.solvedPath).data;\n        },\n        get currentData() {\n          return self.get();\n        }\n      };\n\n      if (this.state.recording && !this.state.undoing)\n        this.archive.add(eventData.previousData);\n\n      this.state.undoing = false;\n\n      return this.emit('update', eventData);\n    };\n\n    /**\n     * Listener bound to the tree's updates and determining whether the\n     * cursor is affected and should react accordingly.\n     *\n     * Note that this listener is lazily bound to the tree to be sure\n     * one wouldn't leak listeners when only creating cursors for convenience\n     * and not to listen to updates specifically.\n     *\n     * @param {object} event - The event fired by the tree.\n     */\n    this._updateHandler = (event) => {\n      if (this.state.killed)\n        return;\n\n      const {paths, previousData} = event.data,\n            update = fireUpdate.bind(this, previousData),\n            comparedPaths = this._getComparedPaths();\n\n      if (solveUpdate(paths, comparedPaths))\n        return update();\n    };\n\n    // Lazy binding\n    let bound = false;\n    this._lazyBind = () => {\n      if (bound)\n        return;\n\n      bound = true;\n\n      if (this._dynamicPath)\n        this.tree.on('write', this._writeHandler);\n\n      return this.tree.on('update', this._updateHandler);\n    };\n\n    // If the path is dynamic, we actually need to listen to the tree\n    if (this._dynamicPath) {\n      this._lazyBind();\n    }\n    else {\n\n      // Overriding the emitter `on` and `once` methods\n      this.on = before(this._lazyBind, this.on.bind(this));\n      this.once = before(this._lazyBind, this.once.bind(this));\n    }\n  }\n\n  /**\n   * Internal helpers\n   * -----------------\n   */\n\n  /**\n   * Method returning the paths of the tree watched over by the cursor and that\n   * should be taken into account when solving a potential update.\n   *\n   * @return {array} - Array of paths to compare with a given update.\n   */\n  _getComparedPaths() {\n\n    // Checking whether we should keep track of some dependencies\n    const additionalPaths = this._monkeyPath ?\n      getIn(this.tree._monkeys, this._monkeyPath)\n        .data\n        .relatedPaths() :\n      [];\n\n    return [this.solvedPath].concat(additionalPaths);\n  }\n\n  /**\n   * Predicates\n   * -----------\n   */\n\n  /**\n   * Method returning whether the cursor is at root level.\n   *\n   * @return {boolean} - Is the cursor the root?\n   */\n  isRoot() {\n    return !this.path.length;\n  }\n\n  /**\n   * Method returning whether the cursor is at leaf level.\n   *\n   * @return {boolean} - Is the cursor a leaf?\n   */\n  isLeaf() {\n    return type.primitive(this._get().data);\n  }\n\n  /**\n   * Method returning whether the cursor is at branch level.\n   *\n   * @return {boolean} - Is the cursor a branch?\n   */\n  isBranch() {\n    return !this.isRoot() && !this.isLeaf();\n  }\n\n  /**\n   * Traversal Methods\n   * ------------------\n   */\n\n  /**\n   * Method returning the root cursor.\n   *\n   * @return {Baobab} - The root cursor.\n   */\n  root() {\n    return this.tree.select();\n  }\n\n  /**\n   * Method selecting a subpath as a new cursor.\n   *\n   * Arity (1):\n   * @param  {path} path    - The path to select.\n   *\n   * Arity (*):\n   * @param  {...step} path - The path to select.\n   *\n   * @return {Cursor}       - The created cursor.\n   */\n  select(path) {\n    if (arguments.length > 1)\n      path = arrayFrom(arguments);\n\n    return this.tree.select(this.path.concat(path));\n  }\n\n  /**\n   * Method returning the parent node of the cursor or else `null` if the\n   * cursor is already at root level.\n   *\n   * @return {Baobab} - The parent cursor.\n   */\n  up() {\n    if (!this.isRoot())\n      return this.tree.select(this.path.slice(0, -1));\n\n    return null;\n  }\n\n  /**\n   * Method returning the child node of the cursor.\n   *\n   * @return {Baobab} - The child cursor.\n   */\n  down() {\n    checkPossibilityOfDynamicTraversal('down', this.solvedPath);\n\n    if (!(this._get().data instanceof Array))\n      throw Error('Baobab.Cursor.down: cannot go down on a non-list type.');\n\n    return this.tree.select(this.solvedPath.concat(0));\n  }\n\n  /**\n   * Method returning the left sibling node of the cursor if this one is\n   * pointing at a list. Returns `null` if this cursor is already leftmost.\n   *\n   * @return {Baobab} - The left sibling cursor.\n   */\n  left() {\n    checkPossibilityOfDynamicTraversal('left', this.solvedPath);\n\n    const last = +this.solvedPath[this.solvedPath.length - 1];\n\n    if (isNaN(last))\n      throw Error('Baobab.Cursor.left: cannot go left on a non-list type.');\n\n    return last ?\n      this.tree.select(this.solvedPath.slice(0, -1).concat(last - 1)) :\n      null;\n  }\n\n  /**\n   * Method returning the right sibling node of the cursor if this one is\n   * pointing at a list. Returns `null` if this cursor is already rightmost.\n   *\n   * @return {Baobab} - The right sibling cursor.\n   */\n  right() {\n    checkPossibilityOfDynamicTraversal('right', this.solvedPath);\n\n    const last = +this.solvedPath[this.solvedPath.length - 1];\n\n    if (isNaN(last))\n      throw Error('Baobab.Cursor.right: cannot go right on a non-list type.');\n\n    if (last + 1 === this.up()._get().data.length)\n      return null;\n\n    return this.tree.select(this.solvedPath.slice(0, -1).concat(last + 1));\n  }\n\n  /**\n   * Method returning the leftmost sibling node of the cursor if this one is\n   * pointing at a list.\n   *\n   * @return {Baobab} - The leftmost sibling cursor.\n   */\n  leftmost() {\n    checkPossibilityOfDynamicTraversal('leftmost', this.solvedPath);\n\n    const last = +this.solvedPath[this.solvedPath.length - 1];\n\n    if (isNaN(last))\n      throw Error('Baobab.Cursor.leftmost: cannot go left on a non-list type.');\n\n    return this.tree.select(this.solvedPath.slice(0, -1).concat(0));\n  }\n\n  /**\n   * Method returning the rightmost sibling node of the cursor if this one is\n   * pointing at a list.\n   *\n   * @return {Baobab} - The rightmost sibling cursor.\n   */\n  rightmost() {\n    checkPossibilityOfDynamicTraversal('rightmost', this.solvedPath);\n\n    const last = +this.solvedPath[this.solvedPath.length - 1];\n\n    if (isNaN(last))\n      throw Error(\n        'Baobab.Cursor.rightmost: cannot go right on a non-list type.');\n\n    const list = this.up()._get().data;\n\n    return this.tree\n      .select(this.solvedPath.slice(0, -1).concat(list.length - 1));\n  }\n\n  /**\n   * Method mapping the children nodes of the cursor.\n   *\n   * @param  {function} fn      - The function to map.\n   * @param  {object}   [scope] - An optional scope.\n   * @return {array}            - The resultant array.\n   */\n  map(fn, scope) {\n    checkPossibilityOfDynamicTraversal('map', this.solvedPath);\n\n    const array = this._get().data,\n          l = arguments.length;\n\n    if (!type.array(array))\n      throw Error('baobab.Cursor.map: cannot map a non-list type.');\n\n    return array.map(function(item, i) {\n      return fn.call(\n        l > 1 ? scope : this,\n        this.select(i),\n        i,\n        array\n      );\n    }, this);\n  }\n\n  /**\n   * Getter Methods\n   * ---------------\n   */\n\n  /**\n   * Internal get method. Basically contains the main body of the `get` method\n   * without the event emitting. This is sometimes needed not to fire useless\n   * events.\n   *\n   * @param  {path}   [path=[]]       - Path to get in the tree.\n   * @return {object} info            - The resultant information.\n   * @return {mixed}  info.data       - Data at path.\n   * @return {array}  info.solvedPath - The path solved when getting.\n   */\n  _get(path = []) {\n\n    if (!type.path(path))\n      throw makeError('Baobab.Cursor.getters: invalid path.', {path});\n\n    if (!this.solvedPath)\n      return {data: undefined, solvedPath: null, exists: false};\n\n    return getIn(this.tree._data, this.solvedPath.concat(path));\n  }\n\n  /**\n   * Method used to check whether a certain path exists in the tree starting\n   * from the current cursor.\n   *\n   * Arity (1):\n   * @param  {path}   path           - Path to check in the tree.\n   *\n   * Arity (2):\n   * @param {..step}  path           - Path to check in the tree.\n   *\n   * @return {boolean}               - Does the given path exists?\n   */\n  exists(path) {\n    path = coercePath(path);\n\n    if (arguments.length > 1)\n      path = arrayFrom(arguments);\n\n    return this._get(path).exists;\n  }\n\n  /**\n   * Method used to get data from the tree. Will fire a `get` event from the\n   * tree so that the user may sometimes react upon it to fetch data, for\n   * instance.\n   *\n   * Arity (1):\n   * @param  {path}   path           - Path to get in the tree.\n   *\n   * Arity (2):\n   * @param  {..step} path           - Path to get in the tree.\n   *\n   * @return {mixed}                 - Data at path.\n   */\n  get(path) {\n    path = coercePath(path);\n\n    if (arguments.length > 1)\n      path = arrayFrom(arguments);\n\n    const {data, solvedPath} = this._get(path);\n\n    // Emitting the event\n    this.tree.emit('get', {data, solvedPath, path: this.path.concat(path)});\n\n    return data;\n  }\n\n  /**\n   * Method used to shallow clone data from the tree.\n   *\n   * Arity (1):\n   * @param  {path}   path           - Path to get in the tree.\n   *\n   * Arity (2):\n   * @param  {..step} path           - Path to get in the tree.\n   *\n   * @return {mixed}                 - Cloned data at path.\n   */\n  clone(...args) {\n    const data = this.get(...args);\n\n    return shallowClone(data);\n  }\n\n  /**\n   * Method used to deep clone data from the tree.\n   *\n   * Arity (1):\n   * @param  {path}   path           - Path to get in the tree.\n   *\n   * Arity (2):\n   * @param  {..step} path           - Path to get in the tree.\n   *\n   * @return {mixed}                 - Cloned data at path.\n   */\n  deepClone(...args) {\n    const data = this.get(...args);\n\n    return deepClone(data);\n  }\n\n  /**\n   * Method used to return raw data from the tree, by carefully avoiding\n   * computed one.\n   *\n   * @todo: should be more performant as the cloning should happen as well as\n   * when dropping computed data.\n   *\n   * Arity (1):\n   * @param  {path}   path           - Path to serialize in the tree.\n   *\n   * Arity (2):\n   * @param  {..step} path           - Path to serialize in the tree.\n   *\n   * @return {mixed}                 - The retrieved raw data.\n   */\n  serialize(path) {\n    path = coercePath(path);\n\n    if (arguments.length > 1)\n      path = arrayFrom(arguments);\n\n    if (!type.path(path))\n      throw makeError('Baobab.Cursor.getters: invalid path.', {path});\n\n    if (!this.solvedPath)\n      return undefined;\n\n    const fullPath = this.solvedPath.concat(path);\n\n    const data = deepClone(getIn(this.tree._data, fullPath).data),\n          monkeys = getIn(this.tree._monkeys, fullPath).data;\n\n    const dropComputedData = (d, m) => {\n      if (!type.object(m) || !type.object(d))\n        return;\n\n      for (const k in m) {\n        if (m[k] instanceof Monkey)\n          delete d[k];\n        else\n          dropComputedData(d[k], m[k]);\n      }\n    };\n\n    dropComputedData(data, monkeys);\n    return data;\n  }\n\n  /**\n   * Method used to project some of the data at cursor onto a map or a list.\n   *\n   * @param  {object|array} projection - The projection's formal definition.\n   * @return {object|array}            - The resultant map/list.\n   */\n  project(projection) {\n    if (type.object(projection)) {\n      const data = {};\n\n      for (const k in projection)\n        data[k] = this.get(projection[k]);\n\n      return data;\n    }\n\n    else if (type.array(projection)) {\n      const data = [];\n\n      for (let i = 0, l = projection.length; i < l; i++)\n        data.push(this.get(projection[i]));\n\n      return data;\n    }\n\n    throw makeError('Baobab.Cursor.project: wrong projection.', {projection});\n  }\n\n  /**\n   * History Methods\n   * ----------------\n   */\n\n  /**\n   * Methods starting to record the cursor's successive states.\n   *\n   * @param  {integer} [maxRecords] - Maximum records to keep in memory. Note\n   *                                  that if no number is provided, the cursor\n   *                                  will keep everything.\n   * @return {Cursor}               - The cursor instance for chaining purposes.\n   */\n  startRecording(maxRecords) {\n    maxRecords = maxRecords || Infinity;\n\n    if (maxRecords < 1)\n      throw makeError('Baobab.Cursor.startRecording: invalid max records.', {\n        value: maxRecords\n      });\n\n    this.state.recording = true;\n\n    if (this.archive)\n      return this;\n\n    // Lazy binding\n    this._lazyBind();\n\n    this.archive = new Archive(maxRecords);\n    return this;\n  }\n\n  /**\n   * Methods stopping to record the cursor's successive states.\n   *\n   * @return {Cursor} - The cursor instance for chaining purposes.\n   */\n  stopRecording() {\n    this.state.recording = false;\n    return this;\n  }\n\n  /**\n   * Methods undoing n steps of the cursor's recorded states.\n   *\n   * @param  {integer} [steps=1] - The number of steps to rollback.\n   * @return {Cursor}            - The cursor instance for chaining purposes.\n   */\n  undo(steps = 1) {\n    if (!this.state.recording)\n      throw new Error('Baobab.Cursor.undo: cursor is not recording.');\n\n    const record = this.archive.back(steps);\n\n    if (!record)\n      throw Error('Baobab.Cursor.undo: cannot find a relevant record.');\n\n    this.state.undoing = true;\n    this.set(record);\n\n    return this;\n  }\n\n  /**\n   * Methods returning whether the cursor has a recorded history.\n   *\n   * @return {boolean} - `true` if the cursor has a recorded history?\n   */\n  hasHistory() {\n    return !!(this.archive && this.archive.get().length);\n  }\n\n  /**\n   * Methods returning the cursor's history.\n   *\n   * @return {array} - The cursor's history.\n   */\n  getHistory() {\n    return this.archive ? this.archive.get() : [];\n  }\n\n  /**\n   * Methods clearing the cursor's history.\n   *\n   * @return {Cursor} - The cursor instance for chaining purposes.\n   */\n  clearHistory() {\n    if (this.archive)\n      this.archive.clear();\n    return this;\n  }\n\n  /**\n   * Releasing\n   * ----------\n   */\n\n  /**\n   * Methods releasing the cursor from memory.\n   */\n  release() {\n\n    // Removing listeners on parent\n    if (this._dynamicPath)\n      this.tree.off('write', this._writeHandler);\n\n    this.tree.off('update', this._updateHandler);\n\n    // Unsubscribe from the parent\n    if (this.hash)\n      delete this.tree._cursors[this.hash];\n\n    // Dereferencing\n    delete this.tree;\n    delete this.path;\n    delete this.solvedPath;\n    delete this.archive;\n\n    // Killing emitter\n    this.kill();\n    this.state.killed = true;\n  }\n\n  /**\n   * Output\n   * -------\n   */\n\n  /**\n   * Overriding the `toJSON` method for convenient use with JSON.stringify.\n   *\n   * @return {mixed} - Data at cursor.\n   */\n  toJSON() {\n    return this.serialize();\n  }\n\n  /**\n   * Overriding the `toString` method for debugging purposes.\n   *\n   * @return {string} - The cursor's identity.\n   */\n  toString() {\n    return this._identity;\n  }\n}\n\n/**\n * Method used to allow iterating over cursors containing list-type data.\n *\n * e.g. for(let i of cursor) { ... }\n *\n * @returns {object} -  Each item sequentially.\n */\nif (typeof Symbol === 'function' && typeof Symbol.iterator !== 'undefined') {\n  Cursor.prototype[Symbol.iterator] = function() {\n    const array = this._get().data;\n\n    if (!type.array(array))\n      throw Error('baobab.Cursor.@@iterate: cannot iterate a non-list type.');\n\n    let i = 0;\n\n    const cursor = this,\n          length = array.length;\n\n    return {\n      next() {\n        if (i < length) {\n          return {\n            value: cursor.select(i++)\n          };\n        }\n\n        return {\n          done: true\n        };\n      }\n    };\n  };\n}\n\n/**\n * Setter Methods\n * ---------------\n *\n * Those methods are dynamically assigned to the class for DRY reasons.\n */\n\n// Not using a Set so that ES5 consumers don't pay a bundle size price\nconst INTRANSITIVE_SETTERS = {\n  unset: true,\n  pop: true,\n  shift: true\n};\n\n/**\n * Function creating a setter method for the Cursor class.\n *\n * @param {string}   name          - the method's name.\n * @param {function} [typeChecker] - a function checking that the given value is\n *                                   valid for the given operation.\n */\nfunction makeSetter(name, typeChecker) {\n\n  /**\n   * Binding a setter method to the Cursor class and having the following\n   * definition.\n   *\n   * Note: this is not really possible to make those setters variadic because\n   * it would create an impossible polymorphism with path.\n   *\n   * @todo: perform value validation elsewhere so that tree.update can\n   * beneficiate from it.\n   *\n   * Arity (1):\n   * @param  {mixed} value - New value to set at cursor's path.\n   *\n   * Arity (2):\n   * @param  {path}  path  - Subpath to update starting from cursor's.\n   * @param  {mixed} value - New value to set.\n   *\n   * @return {mixed}       - Data at path.\n   */\n  Cursor.prototype[name] = function(path, value) {\n\n    // We should warn the user if he applies to many arguments to the function\n    if (arguments.length > 2)\n      throw makeError(`Baobab.Cursor.${name}: too many arguments.`);\n\n    // Handling arities\n    if (arguments.length === 1 && !INTRANSITIVE_SETTERS[name]) {\n      value = path;\n      path = [];\n    }\n\n    // Coerce path\n    path = coercePath(path);\n\n    // Checking the path's validity\n    if (!type.path(path))\n      throw makeError(`Baobab.Cursor.${name}: invalid path.`, {path});\n\n    // Checking the value's validity\n    if (typeChecker && !typeChecker(value))\n      throw makeError(`Baobab.Cursor.${name}: invalid value.`, {path, value});\n\n    // Checking the solvability of the cursor's dynamic path\n    if (!this.solvedPath)\n      throw makeError(\n        `Baobab.Cursor.${name}: the dynamic path of the cursor cannot be solved.`,\n        {path: this.path}\n      );\n\n    const fullPath = this.solvedPath.concat(path);\n\n    // Filing the update to the tree\n    return this.tree.update(\n      fullPath,\n      {\n        type: name,\n        value\n      }\n    );\n  };\n}\n\n/**\n * Making the necessary setters.\n */\nmakeSetter('set');\nmakeSetter('unset');\nmakeSetter('apply', type.function);\nmakeSetter('push');\nmakeSetter('concat', type.array);\nmakeSetter('unshift');\nmakeSetter('pop');\nmakeSetter('shift');\nmakeSetter('splice', type.splicer);\nmakeSetter('merge', type.object);\nmakeSetter('deepMerge', type.object);\n","/home/travis/build/npmtest/node-npmtest-baobab/node_modules/baobab/src/helpers.js":"/* eslint eqeqeq: 0 */\n\n/**\n * Baobab Helpers\n * ===============\n *\n * Miscellaneous helper functions.\n */\nimport {Monkey, MonkeyDefinition} from './monkey';\nimport type from './type';\n\n/**\n * Noop function\n */\nconst noop = Function.prototype;\n\nconst hasOwnProp = {}.hasOwnProperty;\n\n/**\n * Function returning the index of the first element of a list matching the\n * given predicate.\n *\n * @param  {array}     a  - The target array.\n * @param  {function}  fn - The predicate function.\n * @return {mixed}        - The index of the first matching item or -1.\n */\nfunction index(a, fn) {\n  let i, l;\n  for (i = 0, l = a.length; i < l; i++) {\n    if (fn(a[i]))\n      return i;\n  }\n  return -1;\n}\n\n/**\n * Efficient slice function used to clone arrays or parts of them.\n *\n * @param  {array} array - The array to slice.\n * @return {array}       - The sliced array.\n */\nfunction slice(array) {\n  const newArray = new Array(array.length);\n\n  let i,\n      l;\n\n  for (i = 0, l = array.length; i < l; i++)\n    newArray[i] = array[i];\n\n  return newArray;\n}\n\n/**\n * Archive abstraction\n *\n * @constructor\n * @param {integer} size - Maximum number of records to store.\n */\nexport class Archive {\n  constructor(size) {\n    this.size = size;\n    this.records = [];\n  }\n\n  /**\n   * Method retrieving the records.\n   *\n   * @return {array} - The records.\n   */\n  get() {\n    return this.records;\n  }\n\n  /**\n   * Method adding a record to the archive\n   *\n   * @param {object}  record - The record to store.\n   * @return {Archive}       - The archive itself for chaining purposes.\n   */\n  add(record) {\n    this.records.unshift(record);\n\n    // If the number of records is exceeded, we truncate the records\n    if (this.records.length > this.size)\n      this.records.length = this.size;\n\n    return this;\n  }\n\n  /**\n   * Method clearing the records.\n   *\n   * @return {Archive} - The archive itself for chaining purposes.\n   */\n  clear() {\n    this.records = [];\n    return this;\n  }\n\n  /**\n   * Method to go back in time.\n   *\n   * @param {integer} steps - Number of steps we should go back by.\n   * @return {number}       - The last record.\n   */\n  back(steps) {\n    const record = this.records[steps - 1];\n\n    if (record)\n      this.records = this.records.slice(steps);\n    return record;\n  }\n}\n\n/**\n * Function creating a real array from what should be an array but is not.\n * I'm looking at you nasty `arguments`...\n *\n * @param  {mixed} culprit - The culprit to convert.\n * @return {array}         - The real array.\n */\nexport function arrayFrom(culprit) {\n  return slice(culprit);\n}\n\n/**\n * Function decorating one function with another that will be called before the\n * decorated one.\n *\n * @param  {function} decorator - The decorating function.\n * @param  {function} fn        - The function to decorate.\n * @return {function}           - The decorated function.\n */\nexport function before(decorator, fn) {\n  return function() {\n    decorator.apply(null, arguments);\n    fn.apply(null, arguments);\n  };\n}\n\n/**\n * Function cloning the given regular expression. Supports `y` and `u` flags\n * already.\n *\n * @param  {RegExp} re - The target regular expression.\n * @return {RegExp}    - The cloned regular expression.\n */\nfunction cloneRegexp(re) {\n  const pattern = re.source;\n\n  let flags = '';\n\n  if (re.global) flags += 'g';\n  if (re.multiline) flags += 'm';\n  if (re.ignoreCase) flags += 'i';\n  if (re.sticky) flags += 'y';\n  if (re.unicode) flags += 'u';\n\n  return new RegExp(pattern, flags);\n}\n\n/**\n * Function cloning the given variable.\n *\n * @todo: implement a faster way to clone an array.\n *\n * @param  {boolean} deep - Should we deep clone the variable.\n * @param  {mixed}   item - The variable to clone\n * @return {mixed}        - The cloned variable.\n */\nfunction cloner(deep, item) {\n  if (!item ||\n      typeof item !== 'object' ||\n      item instanceof Error ||\n      item instanceof MonkeyDefinition ||\n      item instanceof Monkey ||\n      ('ArrayBuffer' in global && item instanceof ArrayBuffer))\n    return item;\n\n  // Array\n  if (type.array(item)) {\n    if (deep) {\n      const a = [];\n\n      let i,\n          l;\n\n      for (i = 0, l = item.length; i < l; i++)\n        a.push(cloner(true, item[i]));\n      return a;\n    }\n\n    return slice(item);\n  }\n\n  // Date\n  if (item instanceof Date)\n    return new Date(item.getTime());\n\n  // RegExp\n  if (item instanceof RegExp)\n    return cloneRegexp(item);\n\n  // Object\n  if (type.object(item)) {\n    const o = {};\n\n    let i, l, k;\n\n    // NOTE: could be possible to erase computed properties through `null`.\n    const props = Object.getOwnPropertyNames(item);\n    for (i = 0, l = props.length; i < l; i++) {\n      k = props[i];\n      if (type.lazyGetter(item, k)) {\n        Object.defineProperty(o, k, {\n          get: Object.getOwnPropertyDescriptor(item, k).get,\n          enumerable: true,\n          configurable: true\n        });\n      }\n      else {\n        Object.defineProperty(o, k, {\n          value: deep ? cloner(true, item[k]) : item[k],\n          enumerable: Object.getOwnPropertyDescriptor(item, k).enumerable,\n          writable: true,\n          configurable: true\n        });\n      }\n    }\n    return o;\n  }\n\n  return item;\n}\n\n/**\n * Exporting shallow and deep cloning functions.\n */\nconst shallowClone = cloner.bind(null, false),\n      deepClone = cloner.bind(null, true);\n\nexport {shallowClone, deepClone};\n\n/**\n * Coerce the given variable into a full-fledged path.\n *\n * @param  {mixed} target - The variable to coerce.\n * @return {array}        - The array path.\n */\nexport function coercePath(target) {\n  if (target || target === 0 || target === '')\n    return target;\n  return [];\n}\n\n/**\n * Function comparing an object's properties to a given descriptive\n * object.\n *\n * @param  {object} object      - The object to compare.\n * @param  {object} description - The description's mapping.\n * @return {boolean}            - Whether the object matches the description.\n */\nfunction compare(object, description) {\n  let ok = true,\n      k;\n\n  // If we reached here via a recursive call, object may be undefined because\n  // not all items in a collection will have the same deep nesting structure.\n  if (!object)\n    return false;\n\n  for (k in description) {\n    if (type.object(description[k])) {\n      ok = ok && compare(object[k], description[k]);\n    }\n    else if (type.array(description[k])) {\n      ok = ok && !!~description[k].indexOf(object[k]);\n    }\n    else {\n      if (object[k] !== description[k])\n        return false;\n    }\n  }\n\n  return ok;\n}\n\n/**\n * Function freezing the given variable if possible.\n *\n * @param  {boolean} deep - Should we recursively freeze the given objects?\n * @param  {object}  o    - The variable to freeze.\n * @return {object}    - The merged object.\n */\nfunction freezer(deep, o) {\n  if (typeof o !== 'object' ||\n      o === null ||\n      o instanceof Monkey)\n    return;\n\n  Object.freeze(o);\n\n  if (!deep)\n    return;\n\n  if (Array.isArray(o)) {\n\n    // Iterating through the elements\n    let i,\n        l;\n\n    for (i = 0, l = o.length; i < l; i++)\n      freezer(true, o[i]);\n  }\n  else {\n    let p,\n        k;\n\n    for (k in o) {\n      if (type.lazyGetter(o, k))\n        continue;\n\n      p = o[k];\n\n      if (!p ||\n          !hasOwnProp.call(o, k) ||\n          typeof p !== 'object' ||\n          Object.isFrozen(p))\n        continue;\n\n      freezer(true, p);\n    }\n  }\n}\n\n/**\n * Exporting both `freeze` and `deepFreeze` functions.\n * Note that if the engine does not support `Object.freeze` then this will\n * export noop functions instead.\n */\nconst isFreezeSupported = (typeof Object.freeze === 'function');\n\nconst freeze = isFreezeSupported ? freezer.bind(null, false) : noop,\n      deepFreeze = isFreezeSupported ? freezer.bind(null, true) : noop;\n\nexport {freeze, deepFreeze};\n\n/**\n * Function retrieving nested data within the given object and according to\n * the given path.\n *\n * @todo: work if dynamic path hit objects also.\n * @todo: memoized perfgetters.\n *\n * @param  {object}  object - The object we need to get data from.\n * @param  {array}   path   - The path to follow.\n * @return {object}  result            - The result.\n * @return {mixed}   result.data       - The data at path, or `undefined`.\n * @return {array}   result.solvedPath - The solved path or `null`.\n * @return {boolean} result.exists     - Does the path exists in the tree?\n */\nconst NOT_FOUND_OBJECT = {data: undefined, solvedPath: null, exists: false};\n\nexport function getIn(object, path) {\n  if (!path)\n    return NOT_FOUND_OBJECT;\n\n  const solvedPath = [];\n\n  let exists = true,\n      c = object,\n      idx,\n      i,\n      l;\n\n  for (i = 0, l = path.length; i < l; i++) {\n    if (!c)\n      return {\n        data: undefined,\n        solvedPath: solvedPath.concat(path.slice(i)),\n        exists: false\n      };\n\n    if (typeof path[i] === 'function') {\n      if (!type.array(c))\n        return NOT_FOUND_OBJECT;\n\n      idx = index(c, path[i]);\n      if (!~idx)\n        return NOT_FOUND_OBJECT;\n\n      solvedPath.push(idx);\n      c = c[idx];\n    }\n    else if (typeof path[i] === 'object') {\n      if (!type.array(c))\n        return NOT_FOUND_OBJECT;\n\n      idx = index(c, e => compare(e, path[i]));\n      if (!~idx)\n        return NOT_FOUND_OBJECT;\n\n      solvedPath.push(idx);\n      c = c[idx];\n    }\n    else {\n      solvedPath.push(path[i]);\n      exists = typeof c === 'object' && path[i] in c;\n      c = c[path[i]];\n    }\n  }\n\n  return {data: c, solvedPath, exists};\n}\n\n/**\n * Little helper returning a JavaScript error carrying some data with it.\n *\n * @param  {string} message - The error message.\n * @param  {object} [data]  - Optional data to assign to the error.\n * @return {Error}          - The created error.\n */\nexport function makeError(message, data) {\n  const err = new Error(message);\n\n  for (const k in data)\n    err[k] = data[k];\n\n  return err;\n}\n\n/**\n * Function taking n objects to merge them together.\n * Note 1): the latter object will take precedence over the first one.\n * Note 2): the first object will be mutated to allow for perf scenarios.\n * Note 3): this function will consider monkeys as leaves.\n *\n * @param  {boolean}   deep    - Whether the merge should be deep or not.\n * @param  {...object} objects - Objects to merge.\n * @return {object}            - The merged object.\n */\nfunction merger(deep, ...objects) {\n  const o = objects[0];\n\n  let t,\n      i,\n      l,\n      k;\n\n  for (i = 1, l = objects.length; i < l; i++) {\n    t = objects[i];\n\n    for (k in t) {\n      if (deep &&\n          type.object(t[k]) &&\n          !(t[k] instanceof Monkey)) {\n        o[k] = merger(true, o[k] || {}, t[k]);\n      }\n      else {\n        o[k] = t[k];\n      }\n    }\n  }\n\n  return o;\n}\n\n/**\n * Exporting both `shallowMerge` and `deepMerge` functions.\n */\nconst shallowMerge = merger.bind(null, false),\n      deepMerge = merger.bind(null, true);\n\nexport {shallowMerge, deepMerge};\n\n/**\n * Solving a potentially relative path.\n *\n * @param  {array} base - The base path from which to solve the path.\n * @param  {array} to   - The subpath to reach.\n * @param  {array}      - The solved absolute path.\n */\nexport function solveRelativePath(base, to) {\n  let solvedPath = [];\n\n  // Coercing to array\n  to = [].concat(to);\n\n  for (let i = 0, l = to.length; i < l; i++) {\n    const step = to[i];\n\n    if (step === '.') {\n      if (!i)\n        solvedPath = base.slice(0);\n    }\n    else if (step === '..') {\n      solvedPath = (!i ? base : solvedPath).slice(0, -1);\n    }\n    else {\n      solvedPath.push(step);\n    }\n  }\n\n  return solvedPath;\n}\n\n/**\n * Function determining whether some paths in the tree were affected by some\n * updates that occurred at the given paths. This helper is mainly used at\n * cursor level to determine whether the cursor is concerned by the updates\n * fired at tree level.\n *\n * NOTES: 1) If performance become an issue, the following threefold loop\n *           can be simplified to a complex twofold one.\n *        2) A regex version could also work but I am not confident it would\n *           be faster.\n *        3) Another solution would be to keep a register of cursors like with\n *           the monkeys and update along this tree.\n *\n * @param  {array} affectedPaths - The paths that were updated.\n * @param  {array} comparedPaths - The paths that we are actually interested in.\n * @return {boolean}             - Is the update relevant to the compared\n *                                 paths?\n */\nexport function solveUpdate(affectedPaths, comparedPaths) {\n  let i, j, k, l, m, n, p, c, s;\n\n  // Looping through possible paths\n  for (i = 0, l = affectedPaths.length; i < l; i++) {\n    p = affectedPaths[i];\n\n    if (!p.length)\n      return true;\n\n    // Looping through logged paths\n    for (j = 0, m = comparedPaths.length; j < m; j++) {\n      c = comparedPaths[j];\n\n      if (!c || !c.length)\n        return true;\n\n      // Looping through steps\n      for (k = 0, n = c.length; k < n; k++) {\n        s = c[k];\n\n        // If path is not relevant, we break\n        // NOTE: the '!=' instead of '!==' is required here!\n        if (s != p[k])\n          break;\n\n        // If we reached last item and we are relevant\n        if (k + 1 === n || k + 1 === p.length)\n          return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Non-mutative version of the splice array method.\n *\n * @param  {array}    array        - The array to splice.\n * @param  {integer}  startIndex   - The start index.\n * @param  {integer}  nb           - Number of elements to remove.\n * @param  {...mixed} elements     - Elements to append after splicing.\n * @return {array}                 - The spliced array.\n */\nexport function splice(array, startIndex, nb, ...elements) {\n  if (nb === undefined && arguments.length === 2)\n    nb = array.length - startIndex;\n  else if (nb === null || nb === undefined)\n    nb = 0;\n  else if (isNaN(+nb))\n    throw new Error(`argument nb ${nb} can not be parsed into a number!`);\n  nb = Math.max(0, nb);\n\n  // Solving startIndex\n  if (type.function(startIndex))\n    startIndex = index(array, startIndex);\n  if (type.object(startIndex))\n    startIndex = index(array, e => compare(e, startIndex));\n\n  // Positive index\n  if (startIndex >= 0)\n    return array\n      .slice(0, startIndex)\n      .concat(elements)\n      .concat(array.slice(startIndex + nb));\n\n  // Negative index\n  return array\n    .slice(0, array.length + startIndex)\n    .concat(elements)\n    .concat(array.slice(array.length + startIndex + nb));\n}\n\n/**\n * Function returning a unique incremental id each time it is called.\n *\n * @return {integer} - The latest unique id.\n */\nconst uniqid = (function() {\n  let i = 0;\n\n  return function() {\n    return i++;\n  };\n})();\n\nexport {uniqid};\n","/home/travis/build/npmtest/node-npmtest-baobab/node_modules/baobab/src/monkey.js":"/**\n * Baobab Monkeys\n * ===============\n *\n * Exposing both handy monkey definitions and the underlying working class.\n */\nimport type from './type';\nimport update from './update';\nimport {\n  deepFreeze,\n  getIn,\n  makeError,\n  solveUpdate,\n  solveRelativePath\n} from './helpers';\n\n/**\n * Monkey Definition class\n * Note: The only reason why this is a class is to be able to spot it within\n * otherwise ordinary data.\n *\n * @constructor\n * @param {array|object} definition - The formal definition of the monkey.\n */\nexport class MonkeyDefinition {\n  constructor(definition) {\n    const monkeyType = type.monkeyDefinition(definition);\n\n    if (!monkeyType)\n      throw makeError(\n        'Baobab.monkey: invalid definition.',\n        {definition}\n      );\n\n    this.type = monkeyType;\n\n    if (this.type === 'object') {\n      this.getter = definition.get;\n      this.projection = definition.cursors || {};\n      this.paths = Object.keys(this.projection)\n        .map(k => this.projection[k]);\n      this.options = definition.options || {};\n    }\n    else {\n      let offset = 1,\n          options = {};\n\n      if (type.object(definition[definition.length - 1])) {\n        offset++;\n        options = definition[definition.length - 1];\n      }\n\n      this.getter = definition[definition.length - offset];\n      this.projection = definition.slice(0, -offset);\n      this.paths = this.projection;\n      this.options = options;\n    }\n\n    // Coercing paths for convenience\n    this.paths = this.paths.map(p => [].concat(p));\n\n    // Does the definition contain dynamic paths\n    this.hasDynamicPaths = this.paths.some(type.dynamicPath);\n  }\n}\n\n/**\n * Monkey core class\n *\n * @constructor\n * @param {Baobab}           tree       - The bound tree.\n * @param {MonkeyDefinition} definition - A definition instance.\n */\nexport class Monkey {\n  constructor(tree, pathInTree, definition) {\n\n    // Properties\n    this.tree = tree;\n    this.path = pathInTree;\n    this.definition = definition;\n\n    // Adapting the definition's paths & projection to this monkey's case\n    const projection = definition.projection,\n          relative = solveRelativePath.bind(null, pathInTree.slice(0, -1));\n\n    if (definition.type === 'object') {\n      this.projection = Object.keys(projection).reduce(function(acc, k) {\n        acc[k] = relative(projection[k]);\n        return acc;\n      }, {});\n      this.depPaths = Object.keys(this.projection)\n        .map(k => this.projection[k]);\n    }\n    else {\n      this.projection = projection.map(relative);\n      this.depPaths = this.projection;\n    }\n\n    // Internal state\n    this.state = {\n      killed: false\n    };\n\n    /**\n     * Listener on the tree's `write` event.\n     *\n     * When the tree writes, this listener will check whether the updated paths\n     * are of any use to the monkey and, if so, will update the tree's node\n     * where the monkey sits.\n     */\n    this.writeListener = ({data: {path}}) => {\n      if (this.state.killed)\n        return;\n\n      // Is the monkey affected by the current write event?\n      const concerned = solveUpdate([path], this.relatedPaths());\n\n      if (concerned)\n        this.update();\n    };\n\n    /**\n     * Listener on the tree's `monkey` event.\n     *\n     * When another monkey updates, this listener will check whether the\n     * updated paths are of any use to the monkey and, if so, will update the\n     * tree's node where the monkey sits.\n     */\n    this.recursiveListener = ({data: {monkey, path}}) => {\n      if (this.state.killed)\n        return;\n\n      // Breaking if this is the same monkey\n      if (this === monkey)\n        return;\n\n      // Is the monkey affected by the current monkey event?\n      const concerned = solveUpdate([path], this.relatedPaths(false));\n\n      if (concerned)\n        this.update();\n    };\n\n    // Binding listeners\n    this.tree.on('write', this.writeListener);\n    this.tree.on('_monkey', this.recursiveListener);\n\n    // Updating relevant node\n    this.update();\n  }\n\n  /**\n   * Method returning solved paths related to the monkey.\n   *\n   * @param  {boolean} recursive - Should we compute recursive paths?\n   * @return {array}             - An array of related paths.\n   */\n  relatedPaths(recursive = true) {\n    let paths;\n\n    if (this.definition.hasDynamicPaths)\n      paths = this.depPaths.map(\n        p => getIn(this.tree._data, p).solvedPath\n      );\n    else\n      paths = this.depPaths;\n\n    const isRecursive = recursive && this.depPaths.some(\n      p => !! type.monkeyPath(this.tree._monkeys, p)\n    );\n\n    if (!isRecursive)\n      return paths;\n\n    return paths.reduce((accumulatedPaths, path) => {\n      const monkeyPath = type.monkeyPath(this.tree._monkeys, path);\n\n      if (!monkeyPath)\n        return accumulatedPaths.concat([path]);\n\n      // Solving recursive path\n      const relatedMonkey = getIn(this.tree._monkeys, monkeyPath).data;\n\n      return accumulatedPaths.concat(relatedMonkey.relatedPaths());\n    }, []);\n  }\n\n  /**\n   * Method used to update the tree's internal data with a lazy getter holding\n   * the computed data.\n   *\n   * @return {Monkey} - Returns itself for chaining purposes.\n   */\n  update() {\n    const deps = this.tree.project(this.projection);\n\n    const lazyGetter = (function(tree, def, data) {\n      let cache = null,\n          alreadyComputed = false;\n\n      return function() {\n\n        if (!alreadyComputed) {\n          cache = def.getter.apply(\n            tree,\n            def.type === 'object' ?\n              [data] :\n              data\n          );\n\n          if (tree.options.immutable && def.options.immutable !== false)\n            deepFreeze(cache);\n\n          alreadyComputed = true;\n        }\n\n        return cache;\n      };\n    })(this.tree, this.definition, deps);\n\n    lazyGetter.isLazyGetter = true;\n\n    // Should we write the lazy getter in the tree or solve it right now?\n    if (this.tree.options.lazyMonkeys) {\n      this.tree._data = update(\n        this.tree._data,\n        this.path,\n        {\n          type: 'monkey',\n          value: lazyGetter\n        },\n        this.tree.options\n      ).data;\n    }\n    else {\n      const result = update(\n        this.tree._data,\n        this.path,\n        {\n          type: 'set',\n          value: lazyGetter(),\n          options: {\n            mutableLeaf: !this.definition.options.immutable\n          }\n        },\n        this.tree.options\n      );\n\n      if ('data' in result)\n        this.tree._data = result.data;\n    }\n\n    // Notifying the monkey's update so we can handle recursivity\n    this.tree.emit('_monkey', {monkey: this, path: this.path});\n\n    return this;\n  }\n\n  /**\n   * Method releasing the monkey from memory.\n   */\n  release() {\n\n    // Unbinding events\n    this.tree.off('write', this.writeListener);\n    this.tree.off('_monkey', this.recursiveListener);\n    this.state.killed = true;\n\n    // Deleting properties\n    // NOTE: not deleting this.definition because some strange things happen\n    // in the _refreshMonkeys method. See #372.\n    delete this.projection;\n    delete this.depPaths;\n    delete this.tree;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-baobab/node_modules/baobab/src/type.js":"/**\n * Baobab Type Checking\n * =====================\n *\n * Helpers functions used throughout the library to perform some type\n * tests at runtime.\n *\n */\nimport {Monkey} from './monkey';\n\nconst type = {};\n\n/**\n * Helpers\n * --------\n */\n\n/**\n * Checking whether the given variable is of any of the given types.\n *\n * @todo   Optimize this function by dropping `some`.\n *\n * @param  {mixed} target  - Variable to test.\n * @param  {array} allowed - Array of allowed types.\n * @return {boolean}\n */\nfunction anyOf(target, allowed) {\n  return allowed.some(t => type[t](target));\n}\n\n/**\n * Simple types\n * -------------\n */\n\n/**\n * Checking whether the given variable is an array.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.array = function(target) {\n  return Array.isArray(target);\n};\n\n/**\n * Checking whether the given variable is an object.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.object = function(target) {\n  return target &&\n         typeof target === 'object' &&\n         !Array.isArray(target) &&\n         !(target instanceof Date) &&\n         !(target instanceof RegExp) &&\n         !(typeof Map === 'function' && target instanceof Map) &&\n         !(typeof Set === 'function' && target instanceof Set);\n};\n\n/**\n * Checking whether the given variable is a string.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.string = function(target) {\n  return typeof target === 'string';\n};\n\n/**\n * Checking whether the given variable is a number.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.number = function(target) {\n  return typeof target === 'number';\n};\n\n/**\n * Checking whether the given variable is a function.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.function = function(target) {\n  return typeof target === 'function';\n};\n\n/**\n * Checking whether the given variable is a JavaScript primitive.\n *\n * @param  {mixed} target - Variable to test.\n * @return {boolean}\n */\ntype.primitive = function(target) {\n  return target !== Object(target);\n};\n\n/**\n * Complex types\n * --------------\n */\n\n/**\n * Checking whether the given variable is a valid splicer.\n *\n * @param  {mixed} target    - Variable to test.\n * @param  {array} [allowed] - Optional valid types in path.\n * @return {boolean}\n */\ntype.splicer = function(target) {\n  if (!type.array(target) || target.length < 1)\n    return false;\n  if (target.length > 1 && isNaN(+target[1]))\n    return false;\n\n  return anyOf(target[0], ['number', 'function', 'object']);\n};\n\n/**\n * Checking whether the given variable is a valid cursor path.\n *\n * @param  {mixed} target    - Variable to test.\n * @param  {array} [allowed] - Optional valid types in path.\n * @return {boolean}\n */\n\n// Order is important for performance reasons\nconst ALLOWED_FOR_PATH = ['string', 'number', 'function', 'object'];\n\ntype.path = function(target) {\n  if (!target && target !== 0 && target !== '')\n    return false;\n\n  return [].concat(target).every(step => anyOf(step, ALLOWED_FOR_PATH));\n};\n\n/**\n * Checking whether the given path is a dynamic one.\n *\n * @param  {mixed} path - The path to test.\n * @return {boolean}\n */\ntype.dynamicPath = function(path) {\n  return path.some(step => type.function(step) || type.object(step));\n};\n\n/**\n * Retrieve any monkey subpath in the given path or null if the path never comes\n * across computed data.\n *\n * @param  {mixed} data - The data to test.\n * @param  {array} path - The path to test.\n * @return {boolean}\n */\ntype.monkeyPath = function(data, path) {\n  const subpath = [];\n\n  let c = data,\n      i,\n      l;\n\n  for (i = 0, l = path.length; i < l; i++) {\n    subpath.push(path[i]);\n\n    if (typeof c !== 'object')\n      return null;\n\n    c = c[path[i]];\n\n    if (c instanceof Monkey)\n      return subpath;\n  }\n\n  return null;\n};\n\n/**\n * Check if the given object property is a lazy getter used by a monkey.\n *\n * @param  {mixed}   o           - The target object.\n * @param  {string}  propertyKey - The property to test.\n * @return {boolean}\n */\ntype.lazyGetter = function(o, propertyKey) {\n  const descriptor = Object.getOwnPropertyDescriptor(o, propertyKey);\n\n  return descriptor &&\n         descriptor.get &&\n         descriptor.get.isLazyGetter === true;\n};\n\n/**\n * Returns the type of the given monkey definition or `null` if invalid.\n *\n * @param  {mixed} definition - The definition to check.\n * @return {string|null}\n */\ntype.monkeyDefinition = function(definition) {\n\n  if (type.object(definition)) {\n    if (!type.function(definition.get) ||\n        (definition.cursors &&\n         (!type.object(definition.cursors) ||\n          !(Object.keys(definition.cursors).every(k => type.path(definition.cursors[k]))))))\n      return null;\n\n    return 'object';\n  }\n  else if (type.array(definition)) {\n    let offset = 1;\n\n    if (type.object(definition[definition.length - 1]))\n      offset++;\n\n    if (!type.function(definition[definition.length - offset]) ||\n        !definition.slice(0, -offset).every(p => type.path(p)))\n      return null;\n\n    return 'array';\n  }\n\n  return null;\n};\n\n/**\n * Checking whether the given watcher definition is valid.\n *\n * @param  {mixed}   definition - The definition to check.\n * @return {boolean}\n */\ntype.watcherMapping = function(definition) {\n  return type.object(definition) &&\n         Object.keys(definition).every(k => type.path(definition[k]));\n};\n\n/**\n * Checking whether the given string is a valid operation type.\n *\n * @param  {mixed} string - The string to test.\n * @return {boolean}\n */\n\n// Ordered by likeliness\nconst VALID_OPERATIONS = [\n  'set',\n  'apply',\n  'push',\n  'unshift',\n  'concat',\n  'pop',\n  'shift',\n  'deepMerge',\n  'merge',\n  'splice',\n  'unset'\n];\n\ntype.operationType = function(string) {\n  return typeof string === 'string' && !!~VALID_OPERATIONS.indexOf(string);\n};\n\nexport default type;\n","/home/travis/build/npmtest/node-npmtest-baobab/node_modules/baobab/src/update.js":"/**\n * Baobab Update\n * ==============\n *\n * The tree's update scheme.\n */\nimport type from './type';\nimport {\n  freeze,\n  deepFreeze,\n  deepMerge,\n  makeError,\n  shallowClone,\n  shallowMerge,\n  splice\n} from './helpers';\n\nfunction err(operation, expectedTarget, path) {\n  return makeError(\n    `Baobab.update: cannot apply the \"${operation}\" on ` +\n    `a non ${expectedTarget} (path: /${path.join('/')}).`,\n    {path}\n  );\n}\n\n/**\n * Function aiming at applying a single update operation on the given tree's\n * data.\n *\n * @param  {mixed}  data      - The tree's data.\n * @param  {path}   path      - Path of the update.\n * @param  {object} operation - The operation to apply.\n * @param  {object} [opts]    - Optional options.\n * @return {mixed}            - Both the new tree's data and the updated node.\n */\nexport default function update(data, path, operation, opts = {}) {\n  const {type: operationType, value, options: operationOptions = {}} = operation;\n\n  // Dummy root, so we can shift and alter the root\n  const dummy = {root: data},\n        dummyPath = ['root', ...path],\n        currentPath = [];\n\n  // Walking the path\n  let p = dummy,\n      i,\n      l,\n      s;\n\n  for (i = 0, l = dummyPath.length; i < l; i++) {\n\n    // Current item's reference is therefore p[s]\n    // The reason why we don't create a variable here for convenience\n    // is because we actually need to mutate the reference.\n    s = dummyPath[i];\n\n    // Updating the path\n    if (i > 0)\n      currentPath.push(s);\n\n    // If we reached the end of the path, we apply the operation\n    if (i === l - 1) {\n\n      /**\n       * Set\n       */\n      if (operationType === 'set') {\n\n        // Purity check\n        if (opts.pure && p[s] === value)\n          return {node: p[s]};\n\n        if (type.lazyGetter(p, s)) {\n          Object.defineProperty(p, s, {\n            value,\n            enumerable: true,\n            configurable: true\n          });\n        }\n        else if (opts.persistent && !operationOptions.mutableLeaf) {\n          p[s] = shallowClone(value);\n        }\n        else {\n          p[s] = value;\n        }\n      }\n\n      /**\n       * Monkey\n       */\n      else if (operationType === 'monkey') {\n        Object.defineProperty(p, s, {\n          get: value,\n          enumerable: true,\n          configurable: true\n        });\n      }\n\n      /**\n       * Apply\n       */\n      else if (operationType === 'apply') {\n        const result = value(p[s]);\n\n        // Purity check\n        if (opts.pure && p[s] === result)\n          return {node: p[s]};\n\n        if (type.lazyGetter(p, s)) {\n          Object.defineProperty(p, s, {\n            value: result,\n            enumerable: true,\n            configurable: true\n          });\n        }\n        else if (opts.persistent) {\n          p[s] = shallowClone(result);\n        }\n        else {\n          p[s] = result;\n        }\n      }\n\n      /**\n       * Push\n       */\n      else if (operationType === 'push') {\n        if (!type.array(p[s]))\n          throw err(\n            'push',\n            'array',\n            currentPath\n          );\n\n        if (opts.persistent)\n          p[s] = p[s].concat([value]);\n        else\n          p[s].push(value);\n      }\n\n      /**\n       * Unshift\n       */\n      else if (operationType === 'unshift') {\n        if (!type.array(p[s]))\n          throw err(\n            'unshift',\n            'array',\n            currentPath\n          );\n\n        if (opts.persistent)\n          p[s] = [value].concat(p[s]);\n        else\n          p[s].unshift(value);\n      }\n\n      /**\n       * Concat\n       */\n      else if (operationType === 'concat') {\n        if (!type.array(p[s]))\n          throw err(\n            'concat',\n            'array',\n            currentPath\n          );\n\n        if (opts.persistent)\n          p[s] = p[s].concat(value);\n        else\n          p[s].push.apply(p[s], value);\n      }\n\n      /**\n       * Splice\n       */\n      else if (operationType === 'splice') {\n        if (!type.array(p[s]))\n          throw err(\n            'splice',\n            'array',\n            currentPath\n          );\n\n        if (opts.persistent)\n          p[s] = splice.apply(null, [p[s]].concat(value));\n        else\n          p[s].splice.apply(p[s], value);\n      }\n\n      /**\n       * Pop\n       */\n      else if (operationType === 'pop') {\n        if (!type.array(p[s]))\n          throw err(\n            'pop',\n            'array',\n            currentPath\n          );\n\n        if (opts.persistent)\n          p[s] = splice(p[s], -1, 1);\n        else\n          p[s].pop();\n      }\n\n      /**\n       * Shift\n       */\n      else if (operationType === 'shift') {\n        if (!type.array(p[s]))\n          throw err(\n            'shift',\n            'array',\n            currentPath\n          );\n\n        if (opts.persistent)\n          p[s] = splice(p[s], 0, 1);\n        else\n          p[s].shift();\n      }\n\n      /**\n       * Unset\n       */\n      else if (operationType === 'unset') {\n        if (type.object(p))\n          delete p[s];\n\n        else if (type.array(p))\n          p.splice(s, 1);\n      }\n\n      /**\n       * Merge\n       */\n      else if (operationType === 'merge') {\n        if (!type.object(p[s]))\n          throw err(\n            'merge',\n            'object',\n            currentPath\n          );\n\n        if (opts.persistent)\n          p[s] = shallowMerge({}, p[s], value);\n        else\n          p[s] = shallowMerge(p[s], value);\n      }\n\n      /**\n       * Deep merge\n       */\n      else if (operationType === 'deepMerge') {\n        if (!type.object(p[s]))\n          throw err(\n            'deepMerge',\n            'object',\n            currentPath\n          );\n\n        if (opts.persistent)\n          p[s] = deepMerge({}, p[s], value);\n        else\n          p[s] = deepMerge(p[s], value);\n      }\n\n      // Deep freezing the resulting value\n      if (opts.immutable && !operationOptions.mutableLeaf)\n        deepFreeze(p);\n\n      break;\n    }\n\n    // If we reached a leaf, we override by setting an empty object\n    else if (type.primitive(p[s])) {\n      p[s] = {};\n    }\n\n    // Else, we shift the reference and continue the path\n    else if (opts.persistent) {\n      p[s] = shallowClone(p[s]);\n    }\n\n    // Should we freeze the current step before continuing?\n    if (opts.immutable && l > 0)\n      freeze(p);\n\n    p = p[s];\n  }\n\n  // If we are updating a dynamic node, we need not return the affected node\n  if (type.lazyGetter(p, s))\n    return {data: dummy.root};\n\n  // Returning new data object\n  return {data: dummy.root, node: p[s]};\n}\n","/home/travis/build/npmtest/node-npmtest-baobab/node_modules/baobab/src/watcher.js":"/**\n * Baobab Watchers\n * ================\n *\n * Abstraction used to listen and retrieve data from multiple parts of a\n * Baobab tree at once.\n */\nimport Emitter from 'emmett';\nimport Cursor from './cursor';\nimport type from './type';\nimport {\n  getIn,\n  makeError,\n  solveUpdate\n} from './helpers';\n\n/**\n * Watcher class.\n *\n * @constructor\n * @param {Baobab} tree     - The watched tree.\n * @param {object} mapping  - A mapping of the paths to watch in the tree.\n */\nexport default class Watcher extends Emitter {\n  constructor(tree, mapping) {\n    super();\n\n    // Properties\n    this.tree = tree;\n    this.mapping = null;\n\n    this.state = {\n      killed: false\n    };\n\n    // Initializing\n    this.refresh(mapping);\n\n    // Listening\n    this.handler = (e) => {\n      if (this.state.killed)\n        return;\n\n      const watchedPaths = this.getWatchedPaths();\n\n      if (solveUpdate(e.data.paths, watchedPaths))\n        return this.emit('update');\n    };\n\n    this.tree.on('update', this.handler);\n  }\n\n  /**\n   * Method used to get the current watched paths.\n   *\n   * @return {array} - The array of watched paths.\n   */\n  getWatchedPaths() {\n    const rawPaths = Object.keys(this.mapping)\n      .map(k => {\n        const v = this.mapping[k];\n\n        // Watcher mappings can accept a cursor\n        if (v instanceof Cursor)\n          return v.solvedPath;\n\n        return this.mapping[k];\n      });\n\n    return rawPaths.reduce((cp, p) => {\n\n      // Handling path polymorphisms\n      p = [].concat(p);\n\n      // Dynamic path?\n      if (type.dynamicPath(p))\n        p = getIn(this.tree._data, p).solvedPath;\n\n      if (!p)\n        return cp;\n\n      // Facet path?\n      const monkeyPath = type.monkeyPath(this.tree._monkeys, p);\n\n      if (monkeyPath)\n        return cp.concat(\n          getIn(this.tree._monkeys, monkeyPath).data.relatedPaths()\n        );\n\n      return cp.concat([p]);\n    }, []);\n  }\n\n  /**\n   * Method used to return a map of the watcher's cursors.\n   *\n   * @return {object} - TMap of relevant cursors.\n   */\n  getCursors() {\n    const cursors = {};\n\n    Object.keys(this.mapping).forEach(k => {\n      const path = this.mapping[k];\n\n      if (path instanceof Cursor)\n        cursors[k] = path;\n      else\n        cursors[k] = this.tree.select(path);\n    });\n\n    return cursors;\n  }\n\n  /**\n   * Method used to refresh the watcher's mapping.\n   *\n   * @param  {object}  mapping  - The new mapping to apply.\n   * @return {Watcher}          - Itself for chaining purposes.\n   */\n  refresh(mapping) {\n\n    if (!type.watcherMapping(mapping))\n      throw makeError('Baobab.watch: invalid mapping.', {mapping});\n\n    this.mapping = mapping;\n\n    // Creating the get method\n    const projection = {};\n\n    for (const k in mapping)\n      projection[k] = mapping[k] instanceof Cursor ?\n        mapping[k].path :\n        mapping[k];\n\n    this.get = this.tree.project.bind(this.tree, projection);\n  }\n\n  /**\n   * Methods releasing the watcher from memory.\n   */\n  release() {\n\n    this.tree.off('update', this.handler);\n    this.state.killed = true;\n    this.kill();\n  }\n}\n"}